# 面试题-最快的找出100个RTT中耗时最短的IP地址(最大并发数为10)
- (RTT: Round Trip Time), 往返时延
- [B站](https://www.bilibili.com/video/BV12hR3YXEyq)
- 2025年4月7日
#### 思路
1. 10个一组 取最快的那个值
2. 第一组最快的结果出来以后直接pass掉组内的其他结果
3. 第一组的冠军 和第二组比较 若第二组的时间比这个冠军还慢,则直接pass第二组... 依此类推
#### 代码实现
- 使用 ```new AbortController```取消超时的请求.
- 使用for of 循环执行并发请求

```javaScript
 /**
     * 发送请求 返回最短时间
     * 如果已经超出了maxTime 直接返回null;
     * */
    function race(ips, maxTime) {
        return new Promise((resolve, reject) => {
            const controller = new AbortController();
            const signal = controller.signal;
            setTimeout(() => {
                resolve(null);
                // 取消所有请求;
                controller.abort();
            }, maxTime);
            let start = Date.now();
            for (const ip of ips) {
                fetch(`http://${ip}/ping`, {signal}).then(() => {
                    const rtt = Date.now() - start;
                    resolve({
                        ip,
                        rtt,
                    });
                    controller.abort();
                })
            }
        });
    }

    // 按size 对数组进行分组
    function chunk(arr, size) {
        const result = [];
        for (let i = 0; i < arr.length; i += size) {
            result.push(arr.slice(i, i + size));
        }
        return result;
    }

    async function findShortestRTT(ips, parallelCount = 10) {
        // 对ip地址按最大并发数分组
        const ipChunks = chunk(ips, parallelCount);
        let result = {
            ip: '',
            rtt: Infinity,
        }
        for (const chunk of ipChunks) {
            const temp = await race(chunk, result.rtt);
            if (temp) {
                result = temp;
            }
        }
        return result.ip;
    }
    export default findShortestRTT;
```
