# class
- 以下这三个修饰符是在TypeScript类中才能使用，在JavaScript类中是不支持的。 public private protected
1. public
```
class Person {
 name = "前端娱乐圈";
 public age = 18;
}
const res = new Person();
console.log(res.name, res.age) // 前端娱乐圈 18
```
上面可以看到打印结果都能显示出来，name属性没有定义public公共属性，所以类里面定义的属性及方法默认都是public定义。

2. private
   private为类的私有属性，只有在当前类里面才能访问，当前类就是{}里面区域内。在{}外面是不能访问private定义的属性及方法的
```
class Person {
 private name = "前端娱乐圈";
 private age = 18;
}
const res = new Person();
console.log(res.name, res.age) // 这俩行会爆红，当前属性为私有属性，只能在类内部访问

class Scholl extends Person {
    getData() {
        return this.username + "," + this.age
    }
}
const temp = new Scholl()
console.log(temp.getData()) // 爆红~，虽然继承了Person类，但是private定义是只能在当前类访问，子类也不能访问。
```
3. protected
   protected为类的保护属性，只有在当前类和子类可以访问。也就是说用protected属性定义的子类也可以访问。
```
class Person {
    protected username = "前端娱乐圈";
    protected age = 18;
}
const res = new Person();
console.log(res.name, res.age) // 这俩行会爆红，当前属性为私有属性，只能在类内部访问

class Scholl extends Person {
    getData() {
        return this.username + "," + this.age
    }
}
const temp = new Scholl()
console.log(temp.getData()) // 前端娱乐圈，18。可以正常访问父类的属性
```


#### implements 实现
implements关键字只能在class中使用，顾名思义，实现一个新的类，从父级或者从接口实现所有的属性和方法，如果在PersonAll类里面不写进去接口里面已有的属性和方法则会报错。

```
interface frontEnd {
    name: string,
    fn: () => void
}

class PersonAll implements frontEnd {
    name: "前端娱乐圈";
    
    fn() {
        
    }
}
```

#### abstract 抽象类 只能在typescript中使用
抽象类使用abstract关键字定义。abstract抽象方法不能实例化，如果，抽象类里面方法是抽象的，那么本身的类也必须是抽象的，抽象方法不能写函数体。父类里面有抽象方法，那么子类也必须要重新该方法。
```
// 抽象类
abstract class Boss {
    name = "秦";
    call() {} // 抽象方法不能写函数体
}

class A extends Boss {
    call() {
        console.log(this.name);
        console.log("A")
    }
}

class B extends Boss {
    call() {
         console.log("B")
    }
}

new A().call() // 秦 A
```
