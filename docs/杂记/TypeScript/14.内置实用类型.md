1. Exclude 排除 适用于：并集类型
```
interface UtilityFirst {
    name: string
}

interface UtilityLast {
    age: number
}

type TypesTest = UtilityFirst | UtilityLast;

const ObjJson: Exclude<TypesTest, UtilityLast> = {
    name: "前端娱乐圈"
}
```
2. Extract 正好跟上面那个相反，这是选择某一个可赋值的联合类型，从TypesTest类型中只选择UtilityLast类型。
```
interface UtilityFirst {
    name: string
}

interface UtilityLast {
    age: number
}

type TypesTest = UtilityFirst | UtilityLast;

const ObjJson: Extract<TypesTest, UtilityLast> = {
    age: 1
}
```
3. Readonly 把数组或对象的所有属性值转换为只读的。这里只演示一下对象栗子，数组同样的写法。
   适用于：对象、数组
```
 interface UtilityFirst {
    name: string
}

const ObjJson: Readonly<UtilityFirst> = {
    name: "前端娱乐圈"
}
ObjJson.name = "蛙人" // 报错 只读状态
```
4. Partial 把对象的所有属性设置为可选的。我们知道interface只要不设置?修饰符，那么对象都是必选的。这个实用类可以将属性全部转换为可选的。
   适用于：对象

```
interface UtilityFirst {
    name: string
}

const ObjJson: Partial<UtilityFirst> = {
    
}
```
5. Pick 选择对象类型中的部分key值，提取出来。第一个参数目标值，第二个参数联合key
   适用于: 对象

```
interface UtilityFirst {
    name: string,
    age: number,
    hobby: []
}

const ObjJson: Omit<UtilityFirst, "name" | "age"> = {
    name: "前端娱乐圈",
    age: 18
}
```

6. Omit 选择对象类型中的部分key值，过滤掉。第一个参数目标值，第二个参数联合key
   适用于: 对象

```
interface UtilityFirst {
    name: string,
    age: number,
    hobby: string[]
}

const ObjJson: Pick<UtilityFirst, "name" | "age"> = {
    hobby: ["code", "羽毛球"]
}
```
7. Required把对象所有可选属性转换成必选属性。
   适用于：对象
```
interface UtilityFirst {
    name?: string,
    age?: number,
    hobby?: string[]
}

const ObjJson: Required<UtilityFirst> = {
    name: "蛙人",
    age: 18,
    hobby: ["code"]
}
```
8. Record 创建一个对象结果集，第一个参数则是key值，第二个参数则是value值。规定我们只能创建这里面字段值。
   适用于：对象

```
type IndexList = 0 | 1 | 2

const ObjJson: Record<IndexList, "前端娱乐圈"> = {
    0: "前端娱乐圈",
    1: "前端娱乐圈",
    2: "前端娱乐圈"
}
```
