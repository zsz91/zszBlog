# 在多个窗口中拖拽同一张图片
- 获取浏览器相较于整个屏幕的**左边**的距离
- 获取浏览器相较于整个屏幕的**顶部**的距离
- 使用 BroadCast 进行广播
- 拖拽图片
- [B站](https://www.bilibili.com/video/BV1YK4y1q7Yw)
- ![在这里插入图片描述](/public/杂记/6.png)

## 核心代码
### 元素拖拽
- offsetLeft:是一个只读属性，它返回当前元素相对于其定位父元素（offset parent）左边界的距离，单位为像素。
- 这里所说的“定位父元素”是指最近的具有定位（position值为relative、absolute、fixed或sticky）
- 的祖先元素；如果没有这样的祖先元素，则默认是最近的 body 元素。
- pageX: 事件发生时鼠标指针在页面视口（viewport）中的水平坐标（以像素为单位）

### 根据视口坐标换算成屏幕坐标
### 根据屏幕坐标换算成视口坐标
```html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<style>
    .card{
        position: absolute;
        width: 200px;
        height: 300px;
        background-image: url("https://live.staticflickr.com/65535/54454431149_588e3fe049_b.jpg");
        background-position: center;
        background-repeat: no-repeat;
        background-size: cover;
    }
</style>
<body>
<div class="card">

</div>
<script>
    // 拖拽
    const card = document.querySelector('.card');
    const BAR = 100;
    card.onmousedown = (e) => {
        let x = e.pageX - card.offsetLeft; // x 表示鼠标点击点距离 .card 左边缘的距离。
        let y = e.pageY - card.offsetTop; // y 表示鼠标点击点距离 .card 顶边的距离。
        window.onmousemove = (e) => {
            const cx = e.pageX - x;
            const cy = e.pageY - y;
            card.style.left = cx + 'px';
            card.style.top = cy + 'px';
            // 使用 BroadCastChannel 通知其他窗口 卡片在屏幕中的坐标
            channel.postMessage(getScreenPoint(cx, cy));
        };
        window.onmouseup = () => {
            window.onmousemove = null;
            window.onmouseup = null;
        }
    }

    // 根据屏幕坐标获取相对于当前窗口视口的坐标
    function getClientPoint(screenX, screenY) {
        let clientX = screenX - window.screenX;
        let clientY = screenY - window.screenY - BAR;
        return {x: clientX, y: clientY};
    }

    // 根据视口坐标得到屏幕坐标
    function getScreenPoint(clientX, clientY) {
        let screenX = clientX + window.screenX;
        let screenY = clientY + window.screenY + BAR;
        return {x: screenX, y: screenY};
    }
    function init(){
        if(location.search.includes('hidden')) {
            card.style.left = '-1000px';
        }
    }
    init();
    const channel = new BroadcastChannel('card');
    channel.onmessage = (e) => {
        // 接受消息后 通过 屏幕坐标获取视口坐标
        const {x, y} = getClientPoint(e.data.x, e.data.y);
        card.style.left = x + 'px';
        card.style.top = y + 'px';
    }

</script>
</body>
</html>

```
