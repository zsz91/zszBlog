https://zhuanlan.zhihu.com/p/183162379 知乎
#### 出现的原因
1. 在函数中， this 和 arguments 这两个函数的属性，只有在函数执行的时候才会知道它们分别是指向谁
2. 在所有函数调用时都 ‘偷偷地’ 调用了 call(); 为函数设置了 this 对象。
3. 对象方法的调用
```
  var person = {
    name: "掘金果酱淋",
    hello: function(someone) {
      console.log(this + " 你好啊 " + someone);
    }
  };
// 正常调用
 person.hello("world");// [object Object] 你好啊 世界
```
```
 var person = {
    name: "掘金果酱淋",
    hello: function(someone) {
      console.log(this + " 你好啊 " + someone);
    }
  };
// 实际的调用过程
 person.hello.call(person, "world");// [object Object] 你好啊 世界
```
#### 三个函数相同点： 
1. 都是用来改变函数的上下文，也就是this指向的。
2. 非严格模式下: ==如果thisArg是undefined 或者null, 会用global object替换== 其他的所有类型都会调用 ToObject进行转换
```
 function b(){
     
 }
 Object('b') // String {"b"}
```
```
  "use strict"
   function a(m){
   console.log(this, m);  // undefined, 1
       
   }

a.call(undefined, 1)
```
#### 三个函数的区别
1. ```fn.call()```立即调用，返回函数执行结果，this指向第一个参数，后面可有多个参数，并且这些都是fn函数的参数。
```
  fn.call(this参数,形参1，形参2...)
```
2. ```fn.bind()```不会立即调用，而是返回一个绑定后的新函数。

我们不想在函数执行时才被函数的小动作指定this对象，而是要固定this对象，那么bind()方法就是在内部调用了call()或者apply()方法主动指定this对象，同时为了函数可以复用，借用了闭包来保存这个this对象（闭包这里不多说）
```
 const newFn=fn.bind(this参数，函数参数1，函数参数2...)
```
3. ```fn.apply:```立即调用，返回函数的执行结果，this指向第一个参数，第二个参数是个数组（或者是类似数组的对象，如arguments)，这个数组里内容是fn函数的参数。
```
 fn.apply(this参数，参数的数组)
```
4. call能接受任何参数。两个方法必须的参数是第一个——this。
#### 应用场景
1. 当一个object没有某个方法，但是其他的有，我们可以借助call或apply用其他对象的方法来操作。
2. 需要立即调用使用call/apply
3. 传递的参数不多，则可以使用fn.call(thisObj, arg1, arg2 ...)
4. 要传递的参数很多，则可以用数组将参数整理好调用fn.apply(thisObj, [arg1, arg2 ...])
5. 不需要立即执行，而是想生成一个新的函数长期绑定某个函数给某个对象使用，使用const newFn = fn.bind(thisObj); newFn(arg1, arg2...)
6. 为什么有了call 还要有一个 apply? 见下面的代码
```
 Math.max.call(null, ...arr);
 Math.max.apply(null,arr);
 // 将不定参传进去
 求数组最小值：Math.min.apply(null,arr);
 等价于 Math.max(...arr);
 等价于 Math.max(arr[0],arr[1],arr[2],arr[3]...);
```

#### 实现原理
1. call的实现
```
 Function.prototype.myCall = function(thisObj = window){
    thisObj.fn = this //此处this是指调用myCall的function
    let arg = [...arguments].slice(1); // 处理arguments 获取函数参数
    let result = thisObj.fn(...arg) // 执行该函数
    delete thisObj.fn // 删除这个函数 防止污染原对象
    return result // 返回结果
}
```
call 的实现2 (更完善) https://mp.weixin.qq.com/s/VyBjZzrFK25B7DpLXPduhQ
```
 Function.prototype.myCall = function(context,...args){
    let cxt = context || window;
    //将当前被调用的方法定义在cxt.func上.(为了能以对象调用形式绑定this)
    //新建一个唯一的Symbol变量避免重复
    let func = Symbol() 
    cxt[func] = this;
    args = args ? args : []
    //以对象调用形式调用func,此时this指向cxt 也就是传入的需要绑定的this指向
    const res = args.length > 0 ? cxt[func](...args) : cxt[func]();
    //删除该方法，不然会对传入对象造成污染（添加该方法）
    delete cxt[func];
    return res;
}

```
2. apply的实现
```
 Function.prototype.myApply = function (context = window, arr){
    context.fn = this
    let result
    if(!arr){
        result = context.fn()
    } else {
        result = context.fn(...arr)
    }
    delete context.fn
    return result
}
```
3. bind 的实现 (需要借助刚才的apply)
```
 Function.prototype.myBind = function(context){
    //  类型判断
    if(typeof this !== 'function'){
        throw new TypeError('must be a function')
    }
    let self = this // 这个this是调用bind的函数
    let argsArr = [...arguments].slice(1)

    return function(){
        let bindFuncArg = [...arguments]
        // 合并两次传的参数
        let totalArgs = argsArr.concat(bindFuncArg)
        return self.apply(context, totalArgs)
    }
}

```
#### 刁钻代码解析 求二位数组中每一元素的最大值
```
 const arr = [[1,2,3,666,33], [233,5,888,1,2]];
 const maxArr = arr.map((item) => Math.max.apply(null, item));
```

#### 刁钻代码解析2
https://juejin.cn/post/6999781802923524132
```
  function a(){ 
    console.log(this,'a')
};
function b(){
    console.log(this,'b')
}
a.call.call(b,'b') // String {"b"} "b"
```

##### 深度解析Function.prototype.apply.bind(Math.max, null)
1. ``` (item) => Math.max.apply(null, item) ```本质上是一个函数，他的形参是item
2. 为了简化写法需要做如下操作 执行Math.max函数 且函数的第一个参数是 null，第二个参数是item
```
  (item) => Math.max.apply(null, item)
  ==> const functionA = Function.prototype.apply;  
      const M = Math.max;
      const functionB = functionA.bind(M, null); //给他绑定参数 绑定第一个参数为null this执向为M
```
