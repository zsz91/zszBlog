##### Function.name 属性返回函数实例的名称。
```
 function func1(){}
 console.log(func1.name); // func1
```
Function.name属性的属性特性
1. writable false 只读
2. enumerable false 不可枚举
3. configurable true 可改变配置

##### 构造函数的名称
使用new Function(...)语法创建的函数或只是 Function(...) create Function对象及其名称为“anonymous”。
```
(new Function).name; // "anonymous"
```
##### 推断函数名称
变量和方法可以从句法位置推断匿名函数的名称（ECMAScript 2015中新增）。
```
 var f = function() {};
 var object = {
  someMethod: function() {}
};

console.log(f.name); // "f"
console.log(object.someMethod.name); // "someMethod"
```
可在函数表达式中定义函数的名称
```
 var object = {
  someMethod: function object_someMethod() {}
};

console.log(object.someMethod.name); // "object_someMethod"
```
##### 要更改name属性只能使用 Object.defineProperty()。


##### 简写方法的名称
```
 var o = {
  foo(){} // 等价于 foo: function(){}
 };
 o.foo.name; // "foo";
```
##### 绑定函数的名称
 Function.bind() 所创建的函数将会在函数的名称前加上"bound(被捆绑的)" 。
```
 function foo() {};
 foo.bind({}).name; // "bound foo"
```
##### getters 和 setters 的函数名
当通过 get 和 set 访问器来存取属性时, "get" 或 "set" 会出现在函数名称前。
```
 var o = {
  get foo(){},
  set foo(x){}
};

var descriptor = Object.getOwnPropertyDescriptor(o, "foo");
descriptor.get.name; // "get foo"
descriptor.set.name; // "set foo";
```
##### 类中的函数名称
1. 你可以使用obj.constructor.name来检查对象的“类”
```
  function Foo() {}  // ES2015 Syntax: class Foo {}
  var fooInstance = new Foo();
  console.log(fooInstance.constructor.name); // logs "Foo"
```
2. 无法获取具有静态方法属性name()的几乎任何类的类名称：
```
 class Foo {
  constructor() {}
  static name() {}
}
```
你不能依赖内置的Function.name属性来保持一个类的名称。(ES6规定)

##### Symbol作为函数的名称
如果Symbol 被用于函数名称，并且这个symbol具有相应的描述符，那么方法的名字就是方括号中的描述符
```
 var sym1 = Symbol("foo");
 var sym2 = Symbol();
 var o = {
  [sym1]: function(){},
  [sym2]: function(){}
};

 o[sym1].name; // "[foo]"
 o[sym2].name; // ""
```

#### 箭头函数 和 普通函数都是这样
1. 立即执行函数表达式 name 属性为空字符串
```
 (function(){
       console.log(this.name); // 空字符串
       console.log(this.name.length); // 0
   })();
```

3. 匿名函数的name 属性为空字符串
```
  console.log(()=>{}.name) // 报错
  console.log((()=>{}).name) // '' 空字符串
  const a = () => {};
  a.name = '2333';  // a.name 还是 'a';
```