
1. 闭包是一系列代码块（在ECMAScript中是函数），并且静态保存所有父级的作用域。通过这些保存的作用域来搜寻到函数中的自由变量。
2. 使用静态作用域是闭包的一个强制性要求
3. 概念：声明在一个函数中的函数，叫做闭包函数。
4. 内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。
##### 特点
1. 让外部访问 函数内部变量 成为可能；
2. 局部变量会常驻在内存中；
3. 可以避免使用全局变量，防止全局变量污染；
4. 会造成内存泄漏（有一块内存空间被长期占用，而不被释放）
5. 闭包的创建：
闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。闭包会发生内存泄漏，每次外部函数执行的时 候，外部函数的引用地址不同，都会重新创建一个新的地址。但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。
6. 闭包内存泄漏为： key = value，key 被删除了 value 常驻内存中; 局部变量闭包升级版（中间引用的变量） => 自由变量；

 

    上面的都是什么鬼，是人话么，能看懂早就看懂了，生气······    

不过，答应我，看完例子再回看上面的概念，会理解的更！透！彻！

---------------------------------------------我是容易看懂的分界线-----------------------------------------------
https://blog.csdn.net/weixin_43586120/article/details/89456183
直接看代码
结论：闭包找到的是同一地址中父级函数中对应变量最终的值

```
 function outerFn() {
        let i = 0;
        function innerFn() {
          i++;
          console.log(i);
        }
        return innerFn;
      }
      let inner = outerFn(); //每次外部函数执行的时候,都会开辟一块内存空间,外部函数的地址不同，都会重新创建一个新的地址
      inner(); // 1
      inner(); // 2
      inner(); // 3
      let inner2 = outerFn();
      inner2(); // 1
      inner2(); // 2
      inner2(); // 3
```


````
      let i = 0;
      function outerFn() {
        function innnerFn() {
          i++;
          console.log(i);
        }
        return innnerFn;
      }
      let inner1 = outerFn();
      let inner2 = outerFn();
      inner1(); // 1
      inner2(); // 2
      inner1(); // 3
      inner2(); // 4
````

##### 核心作用 把函数内部成员的作用范围延长
2.本质
- 函数在执行的时候会放到一个执行栈上，当函数执行完毕之后会从执行栈上移除。但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员。
#### 闭包的查看
可以使用Chrome调试工具进行断点调试查看闭包发生的时间和地点。
![image](https://note.youdao.com/yws/public/resource/287045c9869441c0f1996bd5cd7cf09b/xmlnote/52DD2378FF5145869407E5ECDEFFFF20/33599)

##### 内存
1. 由于闭包会携带包含它的函数的作用域,因此会比其他函数占用更多的内存.过度使用闭包可能会导致内存占用过多.
##### 闭包与变量
- 作用域链的这种配置机制引出了一个副作用.
闭包只能取得包含函数中任何变量的最后一个值.
每个函数的作用域链中都保存着包含函数的活动对象,所以它们引用的都是同一个变量i.