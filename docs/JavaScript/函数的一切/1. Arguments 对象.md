#### 使用函数内部可用的 arguments 对象来访问函数的实参

#### arguments 是一个对应于传递给函数的参数的类数组对象。
```
 typeof arguments // 'object'; 
```

1. arguments对象是所有（非箭头）函数中都可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。
2. 参数可以直接被设置
```
 arguments[1] = 'new value'; 
```
3. 将argments 转换为真正的数组
```
 const newArr = Array.from(arguments);
 const newArr = [...arguments];
```
4. 如果调用的参数多于正式声明接受的参数，则可以使用arguments对象。这种技术对于可以传递可变数量的参数的函数很有用。使用 arguments.length来确定传递给函数参数的个数，然后使用arguments对象来处理每个参数。要确定函数签名中（输入）参数的数量，请使用Function.length属性。

5. 在严格模式下，剩余参数、默认参数和解构赋值参数的存在不会改变 arguments对象的行为，但是在非严格模式下就有所不同了。
```
 //严格模式下 
 function func(a = 55) {
  arguments[0] = 99; // updating arguments[0] does not also update a
  console.log(a);
}
func(10); // 10
```
6. 当非严格模式中的函数没有包含剩余参数、默认参数和解构赋值，那么arguments对象中的值会跟踪参数的值（反之亦然）。
```
// 非严格模式
 function func(a) {
  arguments[0] = 99;   // 更新了arguments[0] 同样更新了a
  console.log(a);
}
func(10); // 99

function func(a) {
  a = 99;              // 更新了a 同样更新了arguments[0]
  console.log(arguments[0]);
}
func(10); // 99

```

```
// 非严格模式
function func(a = 55) {
  arguments[0] = 99; // updating arguments[0] does not also update a
  console.log(a);
}
func(10); // 10

 function func(a = 55) {
  a = 99; // updating a does not also update arguments[0]
  console.log(arguments[0]);
}
func(10); // 10

function func(a = 55) {
  console.log(arguments[0]); // undefined
  console.log(a); // 55
}
func(); // undefined

```


##### 属性
- `arguments.callee` 指向参数所属的当前执行的函数。
指向调用当前函数的函数。严格模式下禁止访问

- `arguments.length`
传递给函数的参数数量

- `arguments[@@iterator]` 
返回一个新的Arr 迭代器 对象， 该对象包含参数中每个索引的值。

- 注意: 在严格模式下，arguments对象已与过往不同。arguments[@@iterator]不再与函数的实际形参之间共享，同时caller属性也被移除。
```
// 严格模式下
Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them

```