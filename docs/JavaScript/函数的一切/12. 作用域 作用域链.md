https://www.bilibili.com/video/BV1yt4y1Q7TC?p=6 30分钟
##### 作用域
1. [[scope]]在函数创建时被存储－－静态（不变的），永远永远，直至函数销毁。即：函数可以永不调用，但[[scope]]属性已经写入，并存储在函数对象中。
##### 作用域链
1. 作用域链是一个 对象列表(list of objects)，用以检索上下文代码中出现的 标识符(identifiers) 。
1. 作用域: 函数定义时,生成的一个JS内部的隐式属性[scope].
2. 函数存储作用域链的容器叫做作用域链
3. 函数执行完成以后, AO是要销毁的(作用域链销毁)
4. AO是一个即时的存储容器

##### 作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。
1. 标示符[Identifiers]可以理解为变量名称、函数声明和普通参数。例如，当一个函数在自身函数体内需要引用一个变量，但是这个变量并没有在函数内部声明（或者也不是某个参数名），那么这个变量就可以称为自由变量[free variable]。那么我们搜寻这些自由变量就需要用到作用域链。__parent__
我们去搜寻__parent__之前，首先会去__proto__的原型链接中。

##### 函数定义时发生了什么?
1. 创建函数自己的``scopes(作用域)``
2. 创建函数自己的作用域链 scope chain
3. 作用域  => 作用域链  => GO(全局上下文)

##### 函数执行前那一刻发生了什么?
1. 函数作用域链中增加 AO(函数上下文) AO第0位 其他作用域链往后 挪一位
2. 
##### 函数执行时如何修改作用域链
1. 通过 with 语句 TODO
2. 通过 catch 语句 TODO


##### 函数执行结束时发送了什么?
1. 将该函数自己的AO销毁掉(未构成闭包时, 构成闭包时不会销毁)




