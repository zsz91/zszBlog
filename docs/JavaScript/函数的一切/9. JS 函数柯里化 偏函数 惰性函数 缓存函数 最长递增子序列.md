### 什么是柯里化 curry
1. 柯里化是将一个接收多个参数的函数转换为一系列只接受一个参数的函数的过程。例如，f(a, b, c) 变成 f(a)(b)(c)。
2. 以下代码就是实现一个柯里化的函数
3. 柯里化的好处就是我们可以最大程度的``重用``我们的函数。
```
 // 普通的加法函数
function add(a, b, c) {
  return a + b + c;
}

// 手动柯里化版本
function curriedAdd(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    };
  };
}

// 使用示例
console.log(curriedAdd(1)(2)(3)); // 输出: 6
console.log(curriedAdd(5)(10)(15)); // 输出: 30
```
```javascript
function curry(fn) {
  return function curried(...args) {
    // 如果传入的参数数量 >= 原函数期望的参数数量，则执行函数
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      // 否则返回一个新函数，继续收集参数
      return function (...nextArgs) {
        return curried.apply(this, args.concat(nextArgs));
      };
    }
  };
}

// 使用示例
function multiply(a, b, c) {
  return a * b * c;
}

const curriedMultiply = curry(multiply);

console.log(curriedMultiply(2)(3)(4)); // 输出: 24
console.log(curriedMultiply(2, 3)(4));  // 输出: 24
console.log(curriedMultiply(2)(3, 4));  // 输出: 24
```
3. 在loadsh中封装了此方法  import { curry } from 'lodash';
#### 什么是偏函数
1. 在计算机科学中，偏函数应用（Partial Application）是指固定一个函数的某些参数，然后产生另一个更小元的函数。而所谓的元是指函数参数的个数，比如含有一个参数的函数被称为一元函数。
```
// 实现方式
function partial(fn) {
  let args = [].slice.call(arguments, 1);
  return function () {
    const newArgs = args.concat([].slice.call(arguments));
    return fn.apply(this, newArgs);
  };
}

// 使用方法
function buildUri(scheme, domain, path) {
  return `${scheme}://${domain}/${path}`;
}

const myGithubPath = _.partial(buildUri, "https", "github.com");
const profilePath = myGithubPath("semlinker/semlinker");
const awesomeTsPath = myGithubPath("semlinker/awesome-typescript");
```
2. loadsh中封装了此方法 import { partial  } from 'lodash'

2. https://mp.weixin.qq.com/s/NjIvIv7cLNNJGPVOlvqSew
#### 什么是惰性载入函数 (十分有用)
1. 所谓的惰性载入就是当第 1 次根据条件执行函数后，在第 2 次调用函数时，就不再检测条件，直接执行函数。要实现这个功能，我们可以在第 1 次条件判断的时候，在满足判断条件的分支中==覆盖==掉所调用的函数，具体的实现方式如下所示：
```
function addHandler(element, type, handler) {
  if (element.addEventListener) {
    addHandler = function (element, type, handler) {
      element.addEventListener(type, handler, false);
    };
  } else if (element.attachEvent) {
    addHandler = function (element, type, handler) {
      element.attachEvent("on" + type, handler);
    };
  } else {
    addHandler = function (element, type, handler) {
      element["on" + type] = handler;
    };
  }
  // 保证首次调用能正常执行监听
  return addHandler(element, type, handler);
}
```
#### 什么是缓存函数
1. 缓存函数是将函数的计算结果缓存起来，当下次以同样的参数调用该函数时，直接返回已缓存的结果，而无需再次执行函数。这是一种常见的以空间换时间的性能优化手段。
```
 function memorize(fn) {
  const cache = Object.create(null); // 存储缓存数据的对象
  return function (...args) {
    const _args = JSON.stringify(args);
    return cache[_args] || (cache[_args] = fn.apply(fn, args));
  };
};
```
#### 什么是最长递增子序列
1. 在计算机科学中，最长递增子序列（longest increasing subsequence）问题是指，在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。最长递增子序列中的元素在原序列中不一定是连续的。-- 维基百科
