# Promise的各种函数
#### Promise.all(iterable)

1.  它通常在启动多个异步任务并发运行并为其结果创建承诺之后使用，以便人们可以等待所有任务完成。
2.  如果所有的任务都成功了则 返回 一个 resolve 的 Promise 对象 并且values 是一个数组
3.  如果有一个任务 reject 了 则 返回一个 reject 的 Promise 对象,失败的原因是第一个失败的promise 的结果. 
4. ``后续的promise不再执行``(因为整个promise的状态已经变为失败)
4. 参数是一个``可迭代``的Promise对象
<!---->

    const promise1 = Promise.resolve(3);
    const promise2 = 42;
    const promise3 = new Promise((resolve, reject) => {
      setTimeout(resolve, 100, 'foo');
    });

    Promise.all([promise1, promise2, promise3]).then((values) => {
      console.log(values);
    });
    // expected output: Array [3, 42, "foo"]

#### Promise.allSettled(iterable)

<https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled>

1.  接收一个Promise的可迭代对象, 返回一个Promise对象 ==(始终是成功的==)
2.  返回的结果是传入的Promise的结果的数组;
3.  和 Promise.all 的区别: Promise.all 都成功了 才会返回成功, 如果有一个失败了就catch了.

#### Promise.race(iterable)

1.  Promise.race(iterable)方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。
2.  其他 Promise 会继续执行

#### Promise.any ES2021

- Promise.any 方法和 Promise.race 类似——
- 只要给定的迭代中的一个 promise 成功，就采用第一个 promise 的值作为它的返回值，
- 但与 Promise.race 的不同之处在于——它会等到所有 promise 都失败之后，才返回失败的值：

#### Promise.finally 方法

- 不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。

#### Promise.all实战

```
import { Progress } from 'antd';
import { useEffect, useState } from 'react';
import readImageQrCode from "@/pages/SaoMiaoGuanLi/utils/readImageQrCode";
import img from "@/pages/ShiBie/44.jpg";


function makeArray(total) { 
//创建二维数组 5个任务一组
    let taskList = [[]];
    let k = 0;
    for (let i = 0; i < total; i++) {
        if (k >= 5) {
            k = 0;
            taskList.push([]);
        }

        // console.log(i+1);
        let oneTask = () => new Promise((resolve, reject) => {
            readImageQrCode(img).then((res) => {
                resolve(res);
            });
        });
        taskList[taskList.length - 1].push(oneTask);
        k++;
    }
    return taskList;

}

export default function TestPromiseAll(props) {
	const [percent, setPercent] = useState(0);
	const total = 100;
    async function doTaskByForOf() {
        let taskList = makeArray(total);
        let trueRes = [];
        for (let item of taskList) {
            const task = () => new Promise((reslove, reject) => {
            // 5个任务一个组进行并发执行
                Promise.all(item.map((g) => g())).then((r) => {
                    console.log(r);
                    reslove(r);
                });
            });
            let res22 = await task();
            trueRes = [...trueRes,...res22];
            setPercent(parseInt(trueRes.length / total * 100));
        }
    }

	useEffect(() => {
        doTaskByForOf()
	}, []);

	return (
		<div>
			<Progress percent={percent} type='circle' />
		</div>
	);
}

```
#### Promise.try
- ES2025新增 Promise.try 是一个静态方法，它的作用等同于 new Promise()，但是更简单。
- 将普通函数转为Promise
