# WeakRef 提案主要包含两个新功能：

- 可以通过 WeakRef 类来给某个对象创建一个弱引用
- 可以通过 FinalizationRegistry 类，在某个对象被垃圾回收之后，执行一些自定义方法
- 上述两个新功能可以同时使用，也可以单独使用，取决于你的需求。

1. 一个 WeakRef 对象包含一个对于某个对象的弱引用，被称为 目标 或 引用。通过弱引用一个对象，可以让该对象在没有其它引用的情况下被垃圾回收机制回收。
2. WeakRef 主要用来 缓存 和 映射 一些大型对象，当你希望某个对象在不被其它地方引用的情况下及时地被垃圾回收，那么你就可以使用它。
3. 官方建议不要轻易使用 WeakRef 和 finalizer。其中一个原因是它们可能不可预测，另一个是它们并没有真正帮 gc 完成工作，实际上可能会gc的工作更加困难。你可以在它的提案(https://github.com/tc39/proposal-weakrefs#a-note-of-caution)中详细了解其原因。
```
 const myWeakRef = new WeakRef({
  name: 'Cache',
  size: 'unlimited'
})

console.log(myWeakRef.deref())
// Output:
// { name: 'Cache', size: 'unlimited' }

console.log(myWeakRef.deref().name)
// Output:
// 'Cache'

console.log(myWeakRef.deref().size)
// Output:
// 'unlimited'
```

```
// 创建 FinalizationRegistry:
const reg = new FinalizationRegistry((val) => {
  console.log(val)
})

;(() => {
  // 创建新对象:
  const obj = {}

  //为 “obj” 对象注册 finalizer：
  //第一个参数：要为其注册 finalizer 的对象。
  //第二个参数：上面定义的回调函数的值。
  reg.register(obj, 'obj has been garbage-collected.')
})()
// 当 "obj" 被gc回收时输出：
// 'obj has been garbage-collected.'
```