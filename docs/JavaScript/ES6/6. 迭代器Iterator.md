## 如何判断一个对象是不是可迭代
- 可迭代对象（Iterable）是指具有 [Symbol.iterator] 属性的对象，该属性是一个函数，返回一个迭代器。
```javascript
function isIterable(value) {
    return value != null && typeof value[Symbol.iterator] === 'function';
}

// 测试示例
console.log(isIterable([])); // true，数组是可迭代对象
console.log(isIterable('hello')); // true，字符串是可迭代对象
console.log(isIterable(new Map())); // true，Map 是可迭代对象
console.log(isIterable(new Set())); // true，Set 是可迭代对象
console.log(isIterable({})); // false，普通对象不是可迭代对象
console.log(isIterable(null)); // false，null 不是可迭代对象
console.log(isIterable(undefined)); // false，undefined 不是可迭代对象
console.log(isIterable(42)); // false，数字不是可迭代对象
```
### 可迭代器-解构面试题
- 不改变以下代码。使代码成立 （对象增加可迭代）
```javascript
    var [a,b] = {
        a: 3,
        b: 4,
    };
    console.log(a,b);
```
```javascript
 Object.prototype[Symbol.iterator] = function () {
        return Object.values(this)[Symbol.iterator]();
    };
```
### 概念
1. 迭代器(Iterator)是一种接口,为各种不同的数据结构提供统一的访问机制.
2. 任何数据结构只要部署了 Iterator 接口 接口,就可以完成遍历操作(for of ).
3. 本质上是对象的一个属性(Symbol.Iterator).
2. ES6 创造了一种新的遍历命令 for...of, Iterator接口主要供 for...of 消费 forof
3. 以下类型 原生具备 Iterator 接口的数据(可用 for of 遍历) 
```
Array
Arguments
Set
Map
String
TypedArray
NodeList
// 他们都有Symbol.iterator属性它是一个方法.
```
## 工作原理
1. 调用Symbol.iterator方法 创建一个指针对象,指向当前数据结构的起始位置.
2. 第一次调用指针对象的 next 方法, 指针自动指向数据结构的第一个成员.
3. 接下来不断调用 next 方法. 指针一直往后移动,直到指向最后一个成员.
4. 每调用 next 方法返回一个包含 value 和 done 属性的对象.


```
let arr = ['钟是志', '郑常秀', '钟卓廷'];
let iterator = arr[Symbol.iterator]();
console.log(iterator.next()); // {value: '钟是志', done: false}
console.log(iterator.next()); // {value: '郑常秀', done: false}
console.log(iterator.next()); // {value: '钟卓廷', done: false}
console.log(iterator.next()); // {value: undefined, done: true}
```
## 应用
1. ==需要自定义遍历数据的时候,使用迭代器.==
2. 以下代码成功使用 for...of 遍历一个对象.
3. 一般情况下 for of 是不能遍历对象的 !
```
const zsz = {
        stus: [
            'a',
            'b',
            'c',
            'd',
        ],
        [Symbol.iterator](){
            let index = 0;
            return {
                next:  () => {
                    if(index < this.stus.length){
                        const result = {
                            value: this.stus[index],
                            done: false,
                        };
                       index += 1;
                       return result;
                    }else{
                        return {
                            value: this.stus[index],
                            done: true,
                        };
                    }
                }
            }
        }
    };
    for(let x of zsz){
        console.log(x); // 成功遍历 stus
    }
```

