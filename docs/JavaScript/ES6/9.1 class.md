## 概念
1. ES6 提供了更接近传统语言的写法, 引入了 Class(类)这个概念, 作为对象的模版.
2. 通过 class 关键字, 可以定义类.
3. 基本上, ES6 的 class 可以看作只是一个语法糖.
4. 它的绝大部分功能,ES5 都可以做到, 新的 class 写法只是让对象原型的写法更加清晰、更==像==面向对象编程的语法而已.
## 知识点:

1. class 声明类
2. constructor 定义构造函数初始化
3. extends 继承父类
4. super 调用父级构造方法
5. static 定义静态方法和属性 (==实例中不能调用, 子类中能够使用==)
6. 父类的静态方法可以被子类继承.
6. 父类方法可以重写
7. 使用 instanceof  可以判断一个实例是否是某个类的实例.

#### 示例
静态方法也是可以从super对象上调用的。
```
 class Foo {
	static classMethod() {
		return 'hello';
	}
}
class Bar extends Foo {
	static classMethod() {
		return super.classMethod() + ', too';
	}
}
Bar.classMethod();

```

```
ES5 通过构造函数 实例化对象
// 声明
function Phone(brand, price){
    this.brand = brand;
    this.price = price;
}

// 添加方法
Phone.prototype.callYou = function(){
    console.log('我可以打电话给你');
}

let HuaWei = new Phone('华为', 3000);
HuaWei.callYou();  // 我可以打电话给你
console.log(HuaWei);
输出 Phone {
    brand: "华为",
    price: 3000,
    __proto__:  { callYou: ƒ ()
                  constructor: ƒ Phone(brand, price)
                  __proto__: Object
        
    }
    
}
```

```
ES6 通过 class 实例化
class Phone{
    // 构造方法 名字不能修改
     constructor(brand, price){
         this.brand = brand;
         this.price = price;
     }
     callYou(){
         console.log('我可以打电话给你');
     }
 }
let onePlus = new Phone('onePlus', 1999);
console.log(onePlus);
```
##### 类的私有变量与直接赋值 (ES11)
- ```#```声明私有变量
- 直接给属性赋值即可初始化 简化了构造函数
```javascript
 class Hero{
    #aggressivity = 0
    age = 100
    name = "fff"
    constructor (aggressivity){
      this.#aggressivity = aggressivity
    }
    getHurt(){
      return this.#aggressivity
    }
    setAggressivity(aggressivity){
      this.#aggressivity = aggressivity
    }
 }
    const shooter = new Hero(100)
    let hurt = shooter.getHurt()
    console.log(hurt) //100
    console.log(shooter.#aggressivity) //Error : Uncaught SyntaxError: Private field '#aggressivity' must be declared in an enclosing class
```
