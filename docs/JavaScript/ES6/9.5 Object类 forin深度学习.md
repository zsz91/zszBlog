# Object类的方法,forin
## 对象实例的属性

#### 任何对象的实例中都具有下列属性和方法

1.  `constructor`: 构造函数
2.  `hasOwnProperty( propertyName(string) )`: 检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。
3.  `isProtoTypeof(object)`: 检查传入的对象是否是当前对象的原型。
4.  `propertyIsEnumberable( propertyName(string) )`: 用于检查给定的属性是否能够使用for-in语句来枚举
5.  `toLocaleString()`: 返回对象的字符串表示。与执行环境的地区对应。
6.  `[object Object]`
    `toString()`: 返回对象的字符串表示。
7.  `[ Object Object ]`
    `valueOf()`: 返回对象的原始值。

## Object类的方法
### `Object.hasOwn()`
- 返回一个布尔值，指示对象是否具有指定的属性作为其自身的属性（而不是继承它）。
```javascript
	let object = { age: 24 }
	Object.hasOwn(object, 'age') // true
```

#### `Object.keys()`,`Object.values()`

1.  返回一个由一个给定对象的自身可枚举属性组成的数组
2.  还会自动给结果排序 for in 也会排序 Object.values 也会排序
3.  排序 逻辑: 现行规范中，在迭代属性值时，会按属性(key)的`数值顺序`(>=0的数字按从小到大排序. 其他按顺序排序)进行排序
4.  Object.keys,Object.values返回的数组中`不包含`原型链的属性. 用于判断一个属性是来自继承还是来自自身的拓展.
5.  使用for in循环返回得到的属性则`包含`所有.

#### Object.entries()

1.  返回一个给定对象自身可枚举属性的键值对数组
2.  其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。
3.  排序逻辑 和 `Object.keys` 一致
4.  用于创建 Map对象; 键值对的集合
5.  将对象 转换为 二维数组
```javascript
    const o = {a: '钟是志', z: 'info', b: 'xxx'};
    console.log(Object.entries(o));
    // \[\['a','钟是志'], \['z': 'info'], \['b': xxx]]
```

#### Object.fromEntries() ES10 新特性

1.创建对象,传入一个二维数组
2\. 相当于 Object.entries 的逆运算  将 二维数组 转换为 一个对象

#### Object.is()

1.  判断两个值是否为同一个值
2.  和 === 的区别
```javascript
    Object.is(NaN,NaN) // true
    Object.is(+0, -0); // false
    NaN === NaN; // false
    +0 === -0; // true
```

#### Object.assign 对象的合并

1.  可以接收多个参数，第一个参数是目标对象，后面的都是源对象，
2.  将多个原对象的属性和方法都合并到了目标对象上面，如果在这个过程中出现同名的属性（方法），后合并的属性（方法）会覆盖之前的同名属性（方法）。
3.  是浅拷贝
4.  不会合并不可枚举的属性
5.  只能将属性值进行复制，如果属性值是一个get（取值函数）的话，那么会先求值，然后再复制。
6.  将数组转换成对象

```javascript
 const config1 = {a: 1, b: 2};
 const config2 = {c: 4, b: 3};
 Object.assign(config1, config2); 
// config1 = {a: 1, b: 3, c: 4}

const a = {};
const b = [1,2,3];
console.log(Object.assign(a, b)); // {0: 1, 1: 2, 2: 3}

```

#### Object.setPrototypeOf(a,b) 设置a的原型对象为b. 改变的是a
```javascript
      const a = {name: 钟是志};
      const b = {from: '隆昌'};
      Object.setPrototypeOf(a,b);
      console.log(Object.getPrototypeOf(a)); // {from: "隆昌"}
      console.log(a); // {name: "钟是志"} 原型指向b
```

#### Object.getPrototypeOf(a) 函数 返回对象a指向的原型prototype
```javascript

      let objA = {
            a: "钟是志",
            b: "man",
            c: "internet选项",
        };
      let objB = {};
      Object.setPrototypeOf(objB, objA);
      console.log(Object.getPrototypeOf(objB)); // 输出 {a: "钟是志", b: "man", c: "internet选项"}
```

#### Object.create(objeA: object, objB: object) // 创建一个元型是a的新对象.

1.  第二个参数可选。
2.  第二个参数表示添加到新创建对象的可枚举属性（即其自身的属性，而不是原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。
```javascript

    const a = {from: '隆昌'};
    const c = Object.create(a, {name: {
    value: '钟是志',
    writable: true,
    enumerable: true,
    configurable: true,

    }});
    console.log(c); // {name: '钟是志'} 原型是 a
    console.log(Object.getPrototypeOf(c)); // 输出{from: '隆昌'};
```

#### Object.getOwnPropertyDescriptor()

1.  获取一个对象的一个属性的特性.
2.  不能获取原型中的属性

#### Object.getOwnPropertyDescriptors(c, 'name')

    console.log(Object.getOwnPropertyDescriptor(c, "name")); // 输出{from: '隆昌'};
    // 输出 {value: "钟是志", writable: true, enumerable: true, configurable: true}

1.  来获取一个对象的所有自身属性的描述对象。
2.  不包含原型中的属性
```javascript

    Object.getOwnPropertyDescriptors(c);
    {
    name: {
    value: "钟是志",
    writable: true,
    enumerable: true,
    configurable: true,
    }

    }
```

##### 冻结 Object.freeze()

如果真的想将对象冻结，应该使用Object.freeze方法。使对象无法被改变
```javascript
const foo = Object.freeze({});
```
##### Object.seal() 密封对象
- `Object.seal()` 是 JavaScript 中用于改变对象自身属性配置的一项功能。当你对一个对象使用
- `Object.seal()` 方法时，它的主要作用是`“密封”`这个对象。具体来说，这样做会带来两个主要影响：
    1. 不能添加新属性：被密封的对象不能新增任何属性。也就是说，你无法给这个对象定义新的属性。
    2. 不能删除或更改现有属性：对象现有的属性也不能被删除，并且如果这些属性是可配置的（configurable），它们会被转为不可配置（non-configurable）。但是，如果属性的值是可写的，你仍然可以修改这些属性的值。
- 需要注意的是，`Object.seal()` 并不会使对象的所有属性变为只读；如果某个属性是可写的，你还是可以改变其值。如果你希望让对象的属性既不能增加也不能修改或删除，则需要使用 Object.freeze() 方法。
- 可以通过 `Object.isSealed()` 方法来检查一个对象是否已经被密封。示例如下：

```javascript
let obj = { name: "object" };
Object.seal(obj);

console.log(Object.isSealed(obj)); // 输出: true

obj.name = "sealed object"; // 允许修改现有属性
console.log(obj.name); // 输出: sealed object

obj.newProperty = "new"; // 不允许添加新属性
console.log(obj.newProperty); // 输出: undefined
delete obj.name; // 不允许删除属性
console.log(obj.name); // 输出: sealed object
```

除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。(使用递归调用 冻结对象)
```javascript

    var constantize = (obj) => {
      Object.freeze(obj);
      Object.keys(obj).forEach( (key, i) => {
        if ( typeof obj[key] === 'object' ) {
          constantize( obj[key] );
        }
      });
    };
```

#### Object.keys 和 forin 遍历对象的区别

1.  Object.keys 遍历返回的keys不包含原型链的属性
2.  Object.keys 在输出 keys 时执行以下步骤。

*   创建一个空的列表用于存放 keys
*   将==所有合法的数组索引==(正整数)按升序的顺序存入
*   将所有字符串类型索引==按属性创建时间==以升序的顺序存入
*   ~~将所有 Symbol 类型索引按属性创建时间以升序的顺序存入~~
*   返回 keys

1.  这里顺便也纠正一个普遍的误区：有些回答说将所有属性为数字类型的 key 从小到大排序，其实不然，还必须要符合 「合法的数组索引」 ，也即只有正整数才行，==负数或者浮点数，一律当做字符串处理==。

2.  PS：严格来说对象属性没有数字类型的，无论是数字还是字符串，都会被当做字符串来处理。

3.  为什么没有 Symbol 类型? 还记得前面敲黑板让同学们留意的地方吗，因为在 EnumerableOwnPropertyNames 的规范中规定了返回值只应包含字符串属性（上面说了数字其实也是字符串）。所以 Symbol 属性是不会被返回的，可以看 MDN\[14] 上关于 Object.getOwnPropertyNames() 的描述。
    如果要返回 Symbol 属性可以用 Object.getOwnPropertySymbols()\[15]。
    [一行 Object.keys() 引发的血案](https://mp.weixin.qq.com/s/z_-1w0oYcgxoikZ7AsvnMA)
```javascript

    const testObj = {}

    testObj[-1] = ''
    testObj[1] = ''
    testObj[1.1] = ''
    testObj['2'] = ''
    testObj['c'] = ''
    testObj['b'] = ''
    testObj['a'] = ''
    testObj[Symbol(1)] = ''
    testObj[Symbol('a')] = ''
    testObj[Symbol('b')] = ''
    testObj['d'] = ''

    console.log(Object.keys(testObj));
    // ['1', '2', '-1', '1.1', 'c', 'b', 'a', 'd']

    for(var i in foo) {
        if (foo.hasOwnProperty(i)) {
            console.log(i);
        }
    }
```
4. 使用`for-in` 循环遍历 包含自身和原型链中的所有可枚举属性,但是使用 `hasOwnProperty` 函数可以判断是否在自身的属性中.
5. `hasOwnProperty` 是 `Object.prototype` 的一个方法，它可是个好东西，他能判断一个对象是否包含自定义属性而不是原型链上的属性.

6. 为什么这样设计? 浏览器对内存的管理: 这样会提高内存的运行效率. 数字属性排前面 方便定位内存地址 https://www.bilibili.com/video/BV1ym4y1a7Fc
