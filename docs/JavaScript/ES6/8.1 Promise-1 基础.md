# Promise
<https://mp.weixin.qq.com/s/LsIG-V6slciCmNyOLkWPzg>

## 概念

1.  Promise 是ES6 引入的 异步编程的新解决方案.语法上Promise 是一个构造函数,用来封装异步操作并可以获取其成功或失败的结果.
2.  异步问题同步化解决方案
3.  规范文档 [Promise A+](https://juejin.cn/post/6844903649852784647)
4.  主要思想: 观察者模式(订阅, 分发), 返回新的实例实现链式调用

### 重要方法

<https://www.bilibili.com/video/BV1ph411f7Th?p=10&spm_id_from=pageDriver>

1.  Promise构造函数\:Promise(excutor){}
2.  Promise.prototype.then 方法写返回值可以是

*   一个普通的JavaScript值
*   promise对象(成功态或者失败态)
*   throw error

1.  Promise.prototype.catch 方法返回的值和then一样
2.  catch在Promise源码层面上也是一个then,catch也是遵循then的运行原则的;
3.  Promise.then,catch 执行完后会返回一个==新的Promise对象== (链式调用)

### 缺点

1.  无法取消Promise，一旦新建它就会立即执行，无法中途取消。
2.  如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
3.  吞掉错误或异常，错误只能顺序处理，即便在Promise链最后添加catch方法，依然可能存在无法捕捉的错误（catch内部可能会出现错误）
4.  阅读代码不是一眼可以看懂，你只会看到一堆then，必须自己在then的回调函数里面理清逻辑。

### 如何停止一个Promise链?

在要停止的promise链位置添加一个方法，返回一个永远不执行resolve或者reject的Promise，那么这个promise永远处于pending状态，所以永远也不会向下执行then或catch了。这样我们就停止了一个promise链。

     Promise.cancel = Promise.stop = function() {
          return new Promise(function(){})
        }

### 示例

1.  最简单的promise resolve reject

<!---->

    const p = new Promise(function(resolve, reject){
            setTimeout(function(){
                let data = '用户数据';
                // resolve(data);
                let err = '数据读取失败';
                reject(err);
            }, 1000);
        });
        p.then(function (value) { // resolve => 调第一个回调函数
            console.log(value); // 用户数据
        }, function (reason) { // reject => 调第二个回调函数
            console.error(reason); // 数据读取失败
        })

1.  [Promise封装读取文件(利用node.js readFile)](https://www.bilibili.com/video/BV1uK411H7on?p=25)

```
const fs = require('fs');
const p = new Promise((resolve,reject)=>{
    fs.readFile('为学.md', (err,data)=>{ // 读取 md 文件
        if(err) {
            reject(err);
            return false;
        }else{
            resolve(data.toString());
            return true;
        }
    });
});
p.then(function (value) {
    console.log(value);
}, function(reson){
    console.log('读取失败');
});
//使用nodejs执行 node Promise.js 控制台输出以下字符串
为学
天下事有难易乎?
为之,则难者亦易矣;
不为,则易者亦难矣.

```

1.  Promise封装原生AJAX请求

2.  Promise 源码实现

```
const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

function resolvePromise(promise2, x, resolve, reject) {
  if (promise2 === x) {
    return reject(
      new TypeError("Chaining cycle detected for promise #<Promise>")
    );
  }
  let called = false;

  if ((typeof x === "object" && x !== null) || typeof x === "function") {
    try {
      let { then } = x;
      if (typeof then === "function") {
        // 是一个 Promise 继续执行这个Promise 的then
        then.call(
          x,
          (y) => {
            if (called) {
              return;
            }
            called = true;
            resolvePromise(promise2, y, resolve, reject);
            // resolve(y);
          }, // 成功时执行
          (r) => {
            if (called) {
              return;
            }
            called = true;
            reject(r);
          } // 失败时执行
        );
      } else {
        // 其他函数或对象
        resolve(x);
      }
    } catch (e) {
      if (called) {
        return;
      }
      called = true;
      reject(e);
    }
  } else {
    resolve(x);
  }
}

class MyPromise {
  constructor(executor) {
    this.status = PENDING;
    this.value = "";
    this.reason = "";
    this.fulfilledCallBacks = []; // 成功的回调 数组
    this.rejectedCallBacks = []; // 失败的回调 数组
    this.resolve = (value) => {
      // resolve 函数
      if (this.status === PENDING) {
        // 修改状态为成功
        this.status = FULFILLED;
        this.value = value;
      }
      if (this.fulfilledCallBacks.length) {
        // 如果存在成功的回调事件 依次执行
        this.fulfilledCallBacks.map((fn) => {
          fn();
        });
      }
    };
    this.rejected = (reason) => {
      // reject 函数
      if (this.status === PENDING) {
        // 修改状态为失败
        this.status = REJECTED;
        this.reason = reason; // 赋值失败理由
      }
      if (this.rejectedCallBacks.length) {
        // 分发
        this.rejectedCallBacks.map((fn) => {
          // 如果存在失败的回调事件 依次执行
          fn();
        });
      }
    };
    try {
      executor(this.resolve, this.rejected); // 执行
    } catch (err) {
      if (this.status === PENDING) {
        // 如果出错 改变状态为 失败
        this.status = REJECTED;
        this.reason = err.message; // 赋值 失败的信息
      }
    }
  }

  then(success, failed) {
    success = typeof success === "function" ? success : (value) => value; // 没有传入成功的回调的时候 直接返回 value
    failed =
      typeof failed === "function"
        ? failed
        : (reason) => {
            throw reason;
          }; // 没有传入失败的回调的时候 直接抛出 reason
    let promise2 = new MyPromise((resolve, reject) => {
      if (this.status === FULFILLED) {
        // 当前状态为成功时 继续异步执行 success
        setTimeout(() => {
          try {
            let x = typeof success === "function" && success(this.value);
            resolvePromise(promise2, x, resolve, reject);
          } catch (e) {
            reject(e);
          }
        }, 0);
      } else if (this.status === REJECTED) {
        // 当前状态为失败时 继续异步执行 failed
        setTimeout(() => {
          try {
            let x = typeof failed === "function" && failed(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (e) {
            reject(e);
          }
        }, 0);
      } else if (this.status === PENDING) {
        // 当前状态为 等待中
        if (typeof success === "function") {
          //异步 成功事件 订阅
          this.fulfilledCallBacks.push(() => {
            try {
              let x = success(this.value);
              resolvePromise(promise2, x, resolve, reject);
            } catch (e) {
              reject(e);
            }
          });
        }
        if (typeof failed === "function") {
          //异步 失败事件 订阅
          this.rejectedCallBacks.push(() => {
            try {
              let x = failed(this.reason);
              resolvePromise(promise2, x, resolve, reject);
            } catch (e) {
              reject(e);
            }
          });
        }
      }
    });
    return promise2; // 返回新的promise 实例(实现链式调用)
  }

  catch(errorCallback) {
    return this.then(null, errorCallback); // catch方法 直接执行then的 failed
  }
}

export default MyPromise;

```

