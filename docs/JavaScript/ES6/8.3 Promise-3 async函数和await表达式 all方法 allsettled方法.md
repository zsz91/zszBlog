# async await
```javascript
async function asy1() {
    console.log(1);
    await asy2();
    console.log(2);
}

const asy2 = async () => {
    await setTimeout(() => {
        Promise.resolve().then(() => {
            console.log(3);
        });
    }, 0);
};

const asy3 = async () => {
    Promise.resolve().then(() => {
        console.log(6);
    });
}
asy1();
console.log(7);
asy3();
// 1 7 6 2 3 

```
### 总结:
#### 1. async 函数中 第一个 await 前的所有代码都是同步代码.
####  2. await后如果不是一个Promise 浏览器会自动给他转成 Promise.resolve(xxx);
####  3. await的作用: 只要后面等待的Promise一旦完成,立即把后续代码放入微队列!

#### async 和 await

1.  async和await就是生成器加Promise的语法糖
2.  两种语法结合可以让异步代码像同步代码一样
3.  async 函数的返回值是 promise 对象
4.  promise 对象的结果由 async 函数执行的返回值决定
5.  抛出错误 reject
6.  返回 的结果不是一个 Promise 类型的对象 则 resolve
7.  await 必须写在 async 函数中,但async 函数中可以不包含await
8.  await 右侧的表达式一般为 promise 对象
9.  await 返回的是 promise 成功的值
10. await 的 promise 失败了,就会抛出异常,需要通过 ==try...catch== 捕获处理
11. 使用了 async 声明的函数在执行时，也是一个单独的==协程==，我们可以使用 await 来暂停该协程，由于 await 等待的是一个 Promise 对象，我们可以 resolve 来恢复该协程。

```
 async function test1(){
    console.log('test1 begin'); // 2
    let res = await test2(); // 异步 Promise微任务。直接执行
    console.log('reslut', res); // 5 回调执行
    console.log('test1 end'); // 6  回调执行
 }
 
 async function test2(){
    console.log('test2'); // 3
 }
 
 console.log('start'); // 1
 test1(); // 返回值是一个Promise 对象
 console.log('end'); // 4 主线程执行

```

#### 使用async await 实现并发调用

*   [async/await的缺陷](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Async_await) 官网有详细介绍在介绍缺陷的章节
*   有一种模式可以缓解这个问题——通过将 Promise 对象存储在变量中来同时开始它们，然后等待它们全部执行完毕。

<!---->

     async function timeTest() {
      const timeoutPromise1 = timeoutPromise(3000);
      const timeoutPromise2 = timeoutPromise(3000);
      const timeoutPromise3 = timeoutPromise(3000);

      await timeoutPromise1;
      await timeoutPromise2;
      await timeoutPromise3;
    }

#### Promise.all(iterable)

1.  它通常在启动多个异步任务并发运行并为其结果创建承诺之后使用，以便人们可以等待所有任务完成。
2.  如果所有的任务都成功了则 返回 一个 resolve 的 Promise 对象 并且values 是一个数组
3.  如果有一个任务 reject 了 则 返回一个 reject 的 Promise 对象,失败的原因是第一个失败的promise 的结果. 
4. ==后续的promise不再执行==(因为整个promise的状态已经变为失败)
4. ==参数是一个可迭代的Promise对象
<!---->

    const promise1 = Promise.resolve(3);
    const promise2 = 42;
    const promise3 = new Promise((resolve, reject) => {
      setTimeout(resolve, 100, 'foo');
    });

    Promise.all([promise1, promise2, promise3]).then((values) => {
      console.log(values);
    });
    // expected output: Array [3, 42, "foo"]

#### Promise.allSettled(iterable)

<https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled>

1.  接收一个Promise的可迭代对象, 返回一个Promise对象 ==(始终是成功的==)
2.  返回的结果是传入的Promise的结果的数组;
3.  和 Promise.all 的区别: Promise.all 都成功了 才会返回成功, 如果有一个失败了就catch了.

allSettled 的返回结果

![image](https://note.youdao.com/yws/public/resource/2c99dc423023971bf072cbbe88557d96/xmlnote/CD3ADBA24CB640CBACEF5BE66DD13A53/25545)

all 的返回结果(有一个失败了)

![image](https://note.youdao.com/yws/public/resource/2c99dc423023971bf072cbbe88557d96/xmlnote/9DBCB93FE7AC44AEBDC876D61653FD2D/25550)

all的返回结果(所有都成功了)

![image](https://note.youdao.com/yws/public/resource/2c99dc423023971bf072cbbe88557d96/xmlnote/61A9C650A3EA4C568811377C1842543D/25552)

#### Promise.race(iterable)

1.  Promise.race(iterable)方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。
2.  其他 Promise 会继续执行
```
.






```

#### Promise.any ES2021

Promise.any 方法和 Promise.race 类似——只要给定的迭代中的一个 promise 成功，就采用第一个 promise 的值作为它的返回值，但与 Promise.race 的不同之处在于——它会等到所有 promise 都失败之后，才返回失败的值：

#### Promise.finally 方法

不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。

#### Promise.all实战

```
import { Progress } from 'antd';
import { useEffect, useState } from 'react';
import readImageQrCode from "@/pages/SaoMiaoGuanLi/utils/readImageQrCode";
import img from "@/pages/ShiBie/44.jpg";


function makeArray(total) { 
//创建二维数组 5个任务一组
    let taskList = [[]];
    let k = 0;
    for (let i = 0; i < total; i++) {
        if (k >= 5) {
            k = 0;
            taskList.push([]);
        }

        // console.log(i+1);
        let oneTask = () => new Promise((resolve, reject) => {
            readImageQrCode(img).then((res) => {
                resolve(res);
            });
        });
        taskList[taskList.length - 1].push(oneTask);
        k++;
    }
    return taskList;

}

export default function TestPromiseAll(props) {
	const [percent, setPercent] = useState(0);
	const total = 100;
    async function doTaskByForOf() {
        let taskList = makeArray(total);
        let trueRes = [];
        for (let item of taskList) {
            const task = () => new Promise((reslove, reject) => {
            // 5个任务一个组进行并发执行
                Promise.all(item.map((g) => g())).then((r) => {
                    console.log(r);
                    reslove(r);
                });
            });
            let res22 = await task();
            trueRes = [...trueRes,...res22];
            setPercent(parseInt(trueRes.length / total * 100));
        }
    }

	useEffect(() => {
        doTaskByForOf()
	}, []);

	return (
		<div>
			<Progress percent={percent} type='circle' />
		</div>
	);
}

```
#### Promise.try
- ES2025新增 Promise.try 是一个静态方法，它的作用等同于 new Promise()，但是更简单。
- 将普通函数转为Promise
