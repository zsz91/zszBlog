# Reflect
## Reflect的本质
- [B站](https://www.bilibili.com/video/BV13p42197sv)
- 一句话总结: 调用对象基本操作(内部方法)
## 每个方法都和 Proxy的方法 一一对应
为操作对象而提供的新API

1. Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。
2. 这些方法与proxy handlers的方法相同。Reflect不是一个函数对象，因此它是不可构造的。

https://www.jianshu.com/p/4a5eca0536c3

3. 为什么要设计Reflect？
    - 将Object对象的属于语言内部的方法放到Reflect对象上，即从Reflect对象上拿Object对象内部方法。
    - 将用 老Object方法 报错的情况，改为返回false

## 实战一
```javascript
const obj = {
	a: 3,
	b: 2,
	get c() {
		return this.a + this.b;
	},
};

const proxy = new Proxy(obj, {
 get(target, key) {
 	console.log('read', key);
 	// return target[key]; // 这样写 因为this指向没有指向proxy 不会打印 read a 和 read b;
 	return Reflect.get(target, key, proxy); // 这样就会打印 read a 和 read b; 了
 }
});

proxy.c;
```
## 实战二
```javascript
const obj = {
	a: 1,
	b: 2,
	[Symbol()]: 4,
};
Object.defineProperty(obj, 'c', {
	value: 3,
	enumerable: false,
});
console.log(Object.keys(obj)); //  [a, b];
console.log(Reflect.ownKeys(obj)); // ['a', 'b', 'c', Symbol()] 啥都能拿到
```
