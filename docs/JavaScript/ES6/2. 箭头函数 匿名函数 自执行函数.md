## 要点
1. 箭头函数的this 是静态的。 this 始终指向函数声明时所在作用域下的 this 的值。无法使用call等方法改变this。
2. 不能作为构造实例化对象,也不能使用 new 关键字(因为箭头函数没有自己的this，它的this其实是继承了外层执行环境中的this，且this指向永远不会改变,作为构造函数其的this要是指向创建的新对象)
3. 不能使用 arguments 变量
4. call、apply、bind 并不会影响其 this 的指向。
5. 箭头函数没有原型prototype。
6. 箭头函数不能当作 Generator 函数，不能使用 yield 关键字。
6. 简写：当形参有且只有一个的时候可以省略小括号，当代码体只有一条语句的时候可以省略花括号

```
const A = (a) => { return a + 1} 等效于  const A = a => a + 1
```

5. 箭头函数适合与this 无关的回调。 定时器，数组的方法回调。
6. 箭头函数 不适合（并不是说不能） 与 this 有关的回调（ 事件回调，对象的方法）。


```
let ad = document.getElementById('ad');
ad.addEventListener('click', function(){
    this.style.color = red; // 不会报错 this 表示这个dom
})
ad.addEventListener('click', () => {
    this.style.color = red; // 报错 this 指向外层的window
})
```

#### 在ts中使用箭头函数
```
let fun5:(data:number) =>number = (data:number)=> data * data;

```
#### 匿名函数, 自执行函数表达式 与函数的name属性
````
  1. 函数的name属性
  function b() {
        console.log(this); // window 对象
        console.log(this.name === "b"); // false
      }
  b();
  console.log(b.name); // b
  
  2. 匿名函数
     (function () {
        console.log(this); // window 对象
      });
  3. 自执行函数
     (function b(str){
         console.log(this) // window 对象;
         console.log(str) // '123';
     })('123')
````

