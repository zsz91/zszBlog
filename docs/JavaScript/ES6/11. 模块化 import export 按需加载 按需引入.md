# 模块化
## ES2025 延迟加载模块 defer
- 延迟模块加载``defer import module from './heavy.js'`` 
- 相比于 动态 import 一个是 预加载 + 延迟执行 一个是 按需加载 + 立即执行

## 导出同名函数可覆盖
```javascript
export * from 'aaa.js'; 
export functionA from './pathch.js';
// 如果 aaa 中有 functionA 函数 则会被覆盖 (来源:大师课-网络库的选型与沉淀)
```

## 实战 try_catch解决依赖引入
```javascript
try{
		dndKit = require('@dnd-kit/core');
	}catch (e){
		// console.log('依赖未安装');
	}
```

## 实战 umi使用require动态导入
- 不推荐-这样使用在打包时相当于全量打包.会打包``components``下的所有文件
```javascript
	const ThisComponent = require(`@/pages/BigScreen/Components${pathThis}`).default; // 使用common.js CMD 加载组件
```
- 等价于以下代码.都会打包整个路径下的所有文件.
```javascript
const path = '/TestImport';
const TestImport = lazy(() => import(`@/components${path}`));

 <Suspense fallback={<div>Loading...</div>}>
 <TestImport />
</Suspense>
```
## 模块化
1. 模块化是指将一个大的程序文件,拆分成许多小的文件.然后将小文件组合起来.
2. 好处: 防止命名冲突,代码复用,高维护性.

## ES6之前的模块化规范
1. CommonJS => NodeJS、Browserify
2. AMD => requireJS
3. CMD => seaJS

## ES6模块化语法
1. export
2. import
3. 浏览器已全兼容 https://www.caniuse.com/#feat=mdn-javascript_statements_import

#### demo 
1. 注意: 
```<script type='module'>```
```javascript
// 1.js 导出
export default function(){
    console.log(1);
}

// js 原生模块化写法 
//  <script type='module'>
//   import * as all from './1.js';
//   import {default as m} from './1.js';
//   import m2 from './1.js';
//   all.default(); // 1
//   m() // 1
//   m2() // 1
//  </script>
```

```javascript

// 2.js 引入
// 可以看作是入口文件
import m1 from './m1.js'; // 引入模块1
import m2 from './m2.js'; // 引入模块2
import m3 from './m3.js'; // 引入模块3

// html
// <script type='module' src='./2.js'></script>
```

#### [动态import 解决按需加载](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import)
1. 异步加载 异步import
2. 返回的结果是一个promise 对象
3. [官网](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import)

```javascript
 import('./hello.js').then((module) => {
    // module = 加载的文件 
 })
```

#### CMD 模块化: 
- CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。代表作品: seaJs 

- CMD规范整合了CommonJS和AMD规范的特点。

1. 定义没有依赖的模块
```
define(function(require, exports, module){
  exports.xxx = value
  module.exports = value
})
```

2. 定义有依赖的模块
```javascript
define(function(require, exports, module){
  //引入依赖模块(同步)
  var module2 = require('./module2')
  //引入依赖模块(异步)
    require.async('./module3', function (m3) {
    })
  //暴露模块
  exports.xxx = value
})

//引入模块
define(function (require) {
  var m1 = require('./module1')
  var m4 = require('./module4')
  m1.show()
  m4.show()
})
```
#### ES6 模块化: 
- export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。
- export default 模块默认输出, 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。
#### ES6 模块与 CommonJS 模块的差异
- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
- CommonJS 模块是运行时加载，ES6 模块是编译时输出。
#### 所有构建工具（webpack等）都是基于nodejs平台运行的，nodejs默认采用CommonJS  
 - CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。
 - ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。
 - ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。
-  ES6 每一个导入的js模块都是活的， 每一次访问该模块的变量或者函数都是最新的， 这个是ES6模块 与AMD和CMD的区别之一
#### 总结

1. CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。

2. AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。
3. CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重
4. ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。

#### 循环依赖问题:
1. requireJS对于循环依赖是直接执行循环依赖的模块， 会导致在开发的时候给自己挖坑....；
2. ES6 循环依赖导入导出的问题:  
- 如果导出的是对象：那么第一行会先输出一个初始值{},在最后等待file0.js和file1.js执行完毕以后， 才输出file0.js导出的对象；
- 如果是数组：那么第一行会输出一个被静态分析过的初始值undefined,在最后等待file0.js和file1.js执行完毕以后， 才输出file0.js导出的对象；
- 如果是布尔值：那么第一行会输出一个被静态分析过的初始值undefined,在最后等待file0.js和file1.js执行完毕以后， 才输出file0.js导出的布尔值；
- 结论：用ES6的export导出数据接口的时候， 最好统一用函数， 避免在循环依赖的时候， 因为JS会把不同类型的对象静态解析成不同的初始值;




导出一整个文件 
```javascript
 export * from '@/webPublic/zyd_public/utils/utils';

```

#### 一个完整的加载周期大致如下
###### common.js
1. Resolution (解析) –> 
2. Loading (加载) –>
3. Wrapping (私有化) –> 
4. Evaluation (执行) –> 
5. Caching (缓存)

##### ES Modules 的加载过程
1. Construction (解析) ->     
2. Instantiation (实例化、建立链接) -> 
3. Evaluation (执行)
- 这些步骤是异步执行的，每一步都可以看作是相互独立的。这一点跟 CommonJS 有很大不同，对于 CommonJS 来说，每一步都是同步进行的。



可以借助 Babel 相关插件(plugin-transform-modules-commonjs, babel-plugin-transform-commonjs)实现 CommonJS 和 ES Modules 间的相互转换。

https://mp.weixin.qq.com/s/ZHrsNVx6X7JeuPFt_r344w


