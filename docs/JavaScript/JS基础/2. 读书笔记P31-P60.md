# typeof toString()
## typeof 操作符
```javascript
    typeof undefined; // 'undefined'
    typeof true; // 'boolean',
    typeof 'str'; // 'string',
    typeof 123; // 'number'
    typeof {}; // 'object'
    typoef null; // 'object'
    typeof []; // 'object'
    typoef console.log; // 'function'
    typoef symbol; // 'symbol'
    typoef 123n; // 'bigint'
```

## toString() 函数

1.  将数字转换为其他进制的字符串 toString(16) 可用于浮点数
2.  参数可以传进制 。
3.  除了null和undefined都可以使用此方法转换(null和undefined使用此方法会直接报错).
4.  使用Lodash中的 toString ==替代==

```javascript

    let a = 3.1;
    a.toString(2); // 11.00011 二进制 可用于浮点数进制转换 
    3.0.toString(); // '3.0' 
    3.toString(); // 报错 因为会把. 当作小数点
    3..toString(); // '3'
    undefined.toString(); // 报错
    null.toString(); // 报错
```

## String() 函数

- 可以将所有类型的数据转换成字符串 如果是null 和 undefined 会被转换为 ‘null’和 ‘undefined’。使用Lodash中的 toString 替代
```javascript
    String(null) // 'null'
    String(undefined) // 'undefined'
    String(NaN) // 'NaN'

// this.reviewScore = 9;

// bad
const totalScore = this.reviewScore + '';

// good
const totalScore = String(this.reviewScore);
```

## Object

- 任何对象的实例中都具有下列属性和方法
  1.  constructor: 构造函数
  2.  hasOwnProperty( propertyName(string) ): 检查给定的``属性``在当前对象实例中（而不是在实例的原型中）是否存在。
  3.  isProtoTypeof(object): 检查传入的对象是否是当前对象的``原型``。
  4.  propertyIsEnumberable( propertyName(string) ): 用于检查给定的属性是否能够使用for-in语句来``枚举``
  5.  toLocaleString(): 返回对象的字符串表示。与执行环境的地区对应。``[object Object]``
  6.  toString(): 返回对象的字符串表示。 ``[ Object Object ]``
  7.  [valueOf()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf): 返回对象的原始值。

## 操作符

1.  一元操作符：

* 递增递减++ , -- 对任何值都适用,对非number类型的数据先执行Number函数转换成number类型 
* P37最下面详细讲解了操作结果，浮点数使用 ``++`` 或 ``--`` 是非常危险的。（浮点数舍入错误所致P38）。
* ESLINT不推荐 [为什么不推荐使用++ 和 --](https://eslint.org/docs/rules/no-plusplus)
```javascript
    var i = 10;
    var j = 20;
    i
    ++
    j
    // i = 10, j = 21
```

*   对非数值应用一元加(+) 一元减(-) 操作符会使其类型``转换``成number,
*   字符串 转换为数字的方法 + '-2' = -2
*   对数值应用一元加(+) 操作符 不会产生任何影响。
*   一元减-操作符会使其乘以-1;
```javascript
    console.log(-'-2'); // 数字2
```

1.  位操作符\~ & | ^

*   负数的二进制码计算方式.取绝对值=>取反=> +1 .
*   按位非(NOT)   \~ 返回数值的反码.  本质就是操作数的负值再减1  <=>  -x - 1
*   \~\~的作用是去掉小数部分，因为位运算的操作值要求是整数，其结果也是整数，所以经过位运算的都会自动变成整数。

```javascript
 ~~65.999  // 65 
 
```

*   按位与(AND)   &   25 & 3 = 1   两个都是1才取1
*   按位或(OR)    |   25 | 3 = 27  任意一个是1 就取1
*   按位异或(XOR) ^   25 ^ 3 = 26  只有1个1时取1 其他都取0 以上几种操作结果中没有任何关系
*   左移操作符 << 将数值的所有位都向左移动指定位数.  多出来的空位用0补起. 不会影响符号位.
*   有符号的右移 >>  保留符号位.
*   无符号的右移 >>> 不保留符号位.

1.  布尔操作符

*   逻辑非 !  注意: 无论这个值是什么数据类型, ! 操作符都会返回一个布尔值. 同时使用两个逻辑操作符!! = Boolean()转型函数;

```javascript
    !Infinity = false; 
    !NaN = true;
    !1 = false;
```
*   逻辑与 && 有两个操作数 ==逻辑与不一定返回布尔值== 一个短路操作符 P45 详情
*   逻辑或 || 有两个操作数 ==逻辑或不一定返回布尔值== 一个短路操作符 P46 详情

1.  ==乘性操作符 \*乘法 /除法 %余数
    还是会先用Number()函数进行类型转换==
```javascript

    let a = 1 && 2; // 2; 遇到真往后走,遇到假或走到最后就返回当前值
    let a = 0 && 2; // 0;
    let a = 1 || 2; // 1;
    遇到假往后走,遇到真或走到最后返回当前值,
    console.log(2* '-2'); // -4

    Infinity * 0 = Infinity
    Infinity * -Infinity = -Infinity
    NaN / 1 = NaN
    1/NaN = NaN 
    0/0 = NaN;
    123/0 = Infinity
    1/+0 = Infinity //用于判断一个值是否是+0 或者-0
    1/-0 = -Infinity // 用于判断一个值是否是+0 或者-0
    Infinity % 123 = NaN
    123 % 0 = NaN
    Infinity % Infinity = NaN
    NaN && '344' = NaN (ReactNode 会输出NaN 不会输出 344)

```
1.  加性操作符  +加法 -减法 还是会先转换不同的数据类型

*   ==任何数据类型的值 + 字符串都是字符串==
*   加法 转换规则与结果 注意 NaN 与 Infinity P48.
*   两个字符串相加 则拼接字符串
*   ==如果只有一个操作数是字符串则先把另外一个转换为字符串 String() 方法再进行拼接.==
*   减法的NaN 与 Infinity 操作 结果和 加法不同 P49 转换后是NaN 则减法的结果就是NaN

1.  关系操作符 > < <= >= 返回布尔值 也要进行数据转换规则 P50

*   如果两个字符串比较 是比较的字符串==编码值== ASCII 如果是多个字符的从左到右依次比较,直到比较出结果
*   任何操作数与NaN 进行关系比较==都会返回 false==因为NaN不等于任何值包括他本身
*   使用ES6的 Number.isNaN()鉴定NaN
*   1.toString()

```JavaScript
    Number.isNaN(Number(value))
    1. === 1 // true
    1.toString() // 报错 SyntaxError 语法错误
    1.0.toString() === 1..toString() //true 不报错 返回'1'
```
1.  相等操作符 == != === !==  永远不要使用 == 和 !=
2.  条件操作符:三目表达式
3.  赋值操作符 [使用复合赋值+=1 -=1操作 替换 ++ --](https://eslint.org/docs/rules/no-plusplus)
4.  逗号操作符 ==在用于赋值时,逗号操作符总会返回表达式中的最后一项.==
*   let num = (1,2,3,4,5); // num = 5

#### 语句

1.  if语句条件表达式的结果不一定需要是布尔值。 ES会自动调用Boolean()函数转换表达式的结果为布尔值
2.  for语句 需要参考ES6的资料，（块级作用域的区别）
```javascript
  // for循环的;xx;是条件判断语句 只返回xx表达式的布尔值 相当于 Boolean(xx)
     for(let i = 0 ; i < 10; i++ ){
        // 使用break 终止循环
        // 使用 continue 进行下次循环
     }
     // 打印 0-100的整数, () 只能写一句,不能写比较, {} 内不能出现i++ i--
     let i = 100;
     for(; i-- ;){
         console.log(i);
     }
```
  

1.  ``for-in`` ``forin``语句 枚举对象的属性 可以枚举数组,或对象. 循环中 返回实例和原型中所有 `enumerable = true` 的属性
- 尽量使用for-in循环枚举遍历对象 而不用在数组上。并且在枚举时 使用 .``hasOwnProperty==(i)``方法过滤原型属性。
- 如果不做过滤，会导致原型链注入的属性或函数等显示出来，在大多数情况下这是不希望出现的。(要避免使用Object.prototype里的属性名称使用hasOwnProperty 因为hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。)
```javascript
  for (let i in man) {
  if (man.hasOwnProperty(i)) { // 过滤
  console.log(i, ":", man[i]);
  }
}
```
4. ``forof`` ``for-of`` 不能遍历对象
   1.  label 语句 P59 控制循环的中止跳转。
   2.  with 语句 将代码的作用域设置到一个特定的对象中。 类似于ES6中的对象解构。
   3.  switch 语句 在比较值时使用的是全等操作符，`不会进行类型转换`。

## 类型转换

##### 显示类型转换 parseFloat parseInt

```javascript
 Number('123') // 123
 Number(true) // 1
 Number(false) // 0
 Number(null) // 0
 Number(undefined) // NaN
 Number('a') // NaN
 Number('1a') // NaN
 parseInt('1a') // 1
 Number('3.14') // 3.14
 
 parseInt('123') // 123
 parseInt(true) // NaN
 parseInt(false) // NaN
 parseInt(null) // NaN
 parseInt(undefined) // NaN
 parseInt('-3.14') // -3
 parseInt('3.99') // 3 向下取整
 parseInt('10', 16) // 16
 parseInt('abc123') // NaN
 parseInt('   123abc') // 123
 
 parseFloat('   3.14445') // 3.14445
 3.1444555.toFixed(2) // '3.14' 四舍五入保留2位小数 返回字符串
 typeof(3.1444555.toFixed(2)) // 'string'
 
```

##### 隐式类型转换

```javascript
  ++'123' // 124 Numer('123') + 1
  '3'* 2 // 6
  '2' / 1 // 2
  '2' % 1 // 1
  '1' > 2 // false number转换后比较
  'a' > 'b' // ASCII码比较
   1 != '2' // number转换 false
   undefined == 0 // false
   null == 0 // false
   null < 0 // false
   null > 0 // false
   undefined 和 null 不小于 不大于 不等于 0
   undefined == null  // true
   typeof(+ '123') // number  正数
   typeof(- '123') // number  -123 负数
   typeof(+ 'asd') // NaN
   typeof(- 'adfg') // NaN
   
```

