# 事件循环(Event Loop)
- [掘金](https://juejin.cn/post/7326803868326592539)
- [CSDN](https://blog.csdn.net/weixin_47838418/article/details/138093873)
- 事件循环(Event Loop) 也称为 消息循环(Message Loop)
## 概念
- 事件循环:浏览器的工作机制. ``事件循环是异步的实现方式.单线程是异步产生的原因``
- 进程: 程序运行需要有它自己专属的内存空间,可以把这块内存空间简单的理解为进程.(类比家), 进程之间相互独立,即使要通信,也需要双方同意.
- 线程: 是进程中的一个实体, 一个进程中可以有多个线程.(类比人).一个进程至少有一个线程, 进程开启后会自动创建一个线程来运行代码, 该线程称之为主线程.

## 浏览器有哪些进程和线程?
- 浏览器是一个多进程多线程的应用程序
- 当启动浏览器后,会自动启动多个进程. (更多工具-任务管理器-查看进程)
- 主要包括:
    - ``浏览器进程``(图中的浏览器)
    - ``渲染进程``(图中的标签页,一个标签页就是一个渲染进程)
    - ``网络进程``(图中的Service Worker)
      ![在这里插入图片描述](/public/工程化/事件循环/1.png)
### 浏览器进程
- 负责界面显示(浏览器外层界面)、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。
### 网络进程
- 负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。
### 渲染进程
- 渲染进程启动后,会开启一个``渲染主线程``,主线程负责执行 HTML、CSS、JS.
- 默认情况下,浏览器会为每个标签页开启一个新的渲染进程,以保证不同的标签页之间不相互影响.(将来可能会有所改变-解决Chrome占内存的问题)
- 渲染主线程, 交互线程, 网络线程, 计时线程
## 渲染主线程工作有哪些?
- 解析HTML
- 解析CSS
- 计算样式
- 布局
- 处理图层
- 每秒把页面画60次(浏览器帧率FPS)
```javascript
function animate() {
  console.log(new Date().getSeconds()) // 每一秒打印的次数就是浏览器帧率
  requestAnimationFrame(animate);
}
animate();
```
- 执行全局JS代码
- 执行事件处理函数
- 执行计时器的回调函数
- .....
### 如何调度这些任务
- 消息队列!

1. 在最开始的时候, 渲染主线程会进入一个无限循环
2. 每一次循环会检查消息队列中是否有任务存在. 如果有, 就取出第一个任务执行,执行完一个后进入下一次循环; 如果没有,则进入休眠状态.
3. 其他所有线程(包括其他进程的线程) 可以随时向消息队列添加任务. 新任务会加到消息队列的末尾.在添加新任务时, 如果主线程是休眠状态,则会将其唤醒以继续循环拿取任务.  **整个过程, 被称之为事件循环(消息循环).**

## 若干解释
### 何为异步?
- 代码的执行过程中, 会遇到一些无法立即处理的任务, 比如
    - 计时--- ``setTimeout`` , ``setInterval``
    - 网络  -- ``XHR``, ``Fetch``
    - 事件  -- ``addEventListener``
      ![在这里插入图片描述](/public/工程化/事件循环/2.png)
-  渲染主线程承担着极其重要的工作,无论如何都不能阻塞!
#### 使用异步解决阻塞问题
####  面试题：如何理解 JS 的异步？
参考答案：
JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。
如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成**卡死现象**。所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的
**回调函数包装成任务**，加入到消息队列的末尾排队，等待主线程调度执行。
在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。
#### JS为何会阻碍页面渲染
- 交互线程-创建绘制任务传给消息队列
- JS的执行 会影响页面的绘制
  ![在这里插入图片描述](/public/工程化/事件循环/3.png)
#### 任务有优先级吗?
- 任务没有优先级,都在消息队列中先进先出
- 但 **消息队列有优先级**
    - W3C最新解释- **不再使用~~宏队列~~ 的说法**
        - 每个任务都有一个任务类型, 同一个类型的任务必须在一个队列,不同类型的任务可以分属不同的队列. 在一次事件循环中, 浏览器可以根据实际情况从**不同的队列中**取出任务执行.
        -  浏览器必须准备好一个微队列,微队列中的任务优先所有其他任务执行.
        - 在目前版本的Chrome 中 至少包含以下队列
            1. **延时队列**: 用于存放计时器到达后的回调任务, 优先级[低] 
               - setTimeout
               - setInterval
            2. **交互队列**: 用于存放用户操作后产生的事件处理任务, 优先级[高]
            3. **微队列**: 用户存放需要最快执行的任务. 优先级[最高]. 主要包括
               - Promise
               - MutationObserver
               - queueMicrotask: 官方提供的微队列函数 支持2018年之后的chrome
            4. 还有其他很多类型的队列. 绘制等
###### 面试题:阐述一下 JS 的事件循环
- (1)事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。
- (2)在Chrome的源码中，它开启一个不会结束的for循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。
  过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。
- (3) 根据W3C官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行
###### 面试题: JS 中的计时器能做到精确时间吗? 为什么?
- 不行
1. 计算机硬件没有原子钟，无法做到精确计时
2. 操作系统的计时函数本身就有少量偏差，由于JS的计时器最终调用的是操作系统的函数，也就携带了这些偏差
3. 按照W3C的标准，浏览器实现计时器时，如果嵌套层级超过5层，则会带有4毫秒的最少时间，这样在计时时间少于4毫秒时又带来了偏差-**最早的时候 setTimeout 至少有4ms(一帧画面时间),现在不会了**
4. 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差.
