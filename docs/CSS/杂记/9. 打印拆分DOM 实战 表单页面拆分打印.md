# 打印拆分dom 实战 表单页面打印拆分
#### 需求
1. 浏览器中打印 高度未知的复杂table, 如果不做任何处理,使用 window.print() 打印 则打印中存在断行. 不美观. 需要按A4纸高度 拆分table的行进行打印
##### 解决方案1(已弃用)
1. 获取所有的行标签tr元素
2. 通过循环tr元素 和 getBoundingClientRect 获取 每一行的高度
3. 如果循环时高度超过了1页纸的高度 则直接在此tr元素前插入一个指定高度的div.


[流程页面](https://sso.yazjy.com/portal/#/printRouter?id=1517415934468292608&serviceId=1292718735756361728&list=[%229c20d1d9-3b61-41a1-86f3-2d526c9898c8%22,%220d2d002d-e054-4332-81c6-dcc931cf90fb%22,%2269cac105-5aea-4fb3-8aaa-420427b60f85%22,%22eed22b2c-3dd3-4f2b-8f2e-a8e5f2e44977%22,%22c57bd277-fbe1-4296-a229-6ab8f12ec2c4%22,%22fda3547c-4344-4cd1-a909-f07c643f2742%22,%226b3bceed-67aa-4f86-b375-d4ae78fc23ef%22,%223100cebe-ed8a-4a45-9287-e33aa862faad%22,%22bda75696-a6c7-4aa2-8940-4c67ad0a0bcd%22,%22bfa33f0f-ea2c-422c-9f63-2fef16d14d7e%22]&padding=undefined&isTakeFlow=false&isNowProcess=false&isNextProcess=true&hasSingle=true)

#### 基础知识
- 元素查找 [document.querySelectorAll](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelectorAll)
- [CSS 属性选择器](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors)
- [CSS 中 px 与 cm 之间的换算关系](https://developer.mozilla.org/zh-CN/docs/Web/CSS/length)
- [Element.getBoundingClientRect 函数](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect)
- [Node.insertBefore() 节点插入](https://developer.mozilla.org/zh-CN/docs/Web/API/Node/insertBefore)

```
// 定义 config
if(window.smartFormGlobalProps){
    window.smartFormGlobalProps.printPageConfig = {
        splitPrint: true, // 打印时是否拆分页面 禅道bug 26222
        insertDomHeight: '3cm', // 插入的拆分dom 的高度 
        paperHeight: 29, // 打印纸张的高度 A4纸就是29 单位厘米
        printPageIds: ['9c20d1d9-3b61-41a1-86f3-2d526c9898c8'], // 需要拆分的页面的id 数组
    };
}

```


```
function splitPage(config){
  let totalDom = document.getElementById('checkDom');
  const {
    insertDomHeight = '3cm',
    paperHeight = 29,
    printPageIds = [],
  } = config;

  const onePageHeightPixes = Math.ceil(96 * paperHeight / 2.54);   // 一张纸 的高度(像素)
  // https://developer.mozilla.org/zh-CN/docs/Web/CSS/length  1cm = 96px / 2.54
  // A4纸 29.7cm 高

  const { top : totalTop, height : totalHeight  } = totalDom.getBoundingClientRect();
  let insertHeight = onePageHeightPixes;
  for (let item of printPageIds) {
    const trList = document.querySelectorAll(`tr[data-tr-id*="${item}"]`);
    if (trList) {
      trList.forEach((x) => {
        const nodePosition = x.getBoundingClientRect();
        const { top, height } = nodePosition;
        const distance = top + height - totalTop; // 目标元素左下角相对于整个表单左上角的距离;
        if (distance > insertHeight) {
          const divHeight = top - insertHeight + height + insertDomHeight;
          console.log(divHeight);
          insertDiv(x, divHeight + 'px');
          insertHeight = insertHeight + onePageHeightPixes;
        }
      });
    }
  }

}


function insertDiv(dom, height = '5cm'){
  if (!dom) {
    return;
  }
  let parent = dom.parentNode;
  let newNode = document.createElement("div");
  newNode.style.height = height;
  parent.insertBefore(newNode, dom);
}

```


#### 解决方案2
纯css 解决 不用计算任何高度 来自[csdn](https://blog.csdn.net/weixin_34032779/article/details/91833336)
1. 在table 中增加一个3cm 的tfoot
2. 设置table 的tbody 中所有tr page-break-inside page-break-after
```
 <style type="text/css">
        table { page-break-inside:auto }
        tr    { 
                page-break-inside:avoid; page-break-after:auto;
                }
        thead { 
                display:table-header-group;
                }
        tfoot { 
            display:table-footer-group;
            height: 3cm;
        }
    </style>
    
    <table>
    <thead>
    <tr><th>表头</th></tr>
    </thead>
    <tfoot>
    <tr><td style="height: 3cm"></td></tr>
    </tfoot>
    <tbody>
```
##### 解决方案2实战代码
```
function newSplitPage(config){
  const {
    insertDomHeight = 10,
    paperHeight = 29,
    printPageIds = [],
  } = config;
  const tableDom = document.querySelector('#checkDom table');
  console.log(tableDom);
  const newNode = document.createElement('tfoot');
  newNode.style.display = 'table-header-group'; // 非常重要 这样就不会渲染一条横线
  newNode.innerHTML = `<tr><td style="height: 3cm"></td></tr>`;
  tableDom.appendChild(newNode);
  for(let item of printPageIds){
    const trList = document.querySelectorAll(`tr[data-tr-id*="${item}"]`);
    trList.forEach((g) => {
      g.style.pageBreakInside = 'avoid';
      g.style.pageBreakAfter = 'auto';
    })
  }
}
```
