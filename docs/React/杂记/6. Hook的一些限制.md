# Hooks 不能写在if条件语句和for循环语句中的原因
- https://juejin.cn/post/7260516157785538618
- 链表存储的 顺序是固定的，不能改变。
- React Hooks的一个关键原则是每次渲染时都按照相同顺序执行。这是因为React通过静态分析来确保Hooks的正确使用，
- 它们必须按照自上而下的顺序被调用。具体来说：
  - 如果将Hooks写在if条件语句中，那么条件满足与否可能会导致不同的Hooks被调用，从而破坏Hook调用顺序的稳定性。
  - 例如，当某个条件在组件重新渲染时发生变化，可能会导致原本应该被调用的Hook没有被调用，或者原本不应该被调用的Hook被调用了，这样就会
  - 破坏``Hook调用顺序的一致性``。
- 如果将Hooks写在for循环中，那么每次循环时都可能会调用不同的Hooks，或者按照不同的顺序调用Hooks，这同样会违反React Hooks的规则。


# Hook为什么不能写在组件外
- 违反 Hook 规则： 
  - React 依赖 Hook 的调用顺序来正确地将状态和副作用与组件关联。如果 Hook 写在组件外部，React 就无法追踪其调用上下文，导致状态混乱或错误。
- 无法访问组件上下文： 
  - Hook（如 useState, useEffect, useContext）需要在组件渲染时被调用，以关联到当前组件实例。在组件外部调用它们没有意义，也无法获取组件的状态或 props。


# Hook的状态如何与``Fiber``关联
- Hook 的状态如何与 Fiber 关联？
  - 函数组件本身是无状态的（它只是一个函数），那么 useState、useReducer 等 Hook 是如何记住状态的呢？答案就是 Fiber 节点。
  - React 内部为函数组件的 Fiber 节点维护了一个 链表（linked list） 来存储 Hook 的状态。这个链表的每个节点代表一个 Hook。

- 具体过程如下：

1. 初始化： 当函数组件首次渲染时，React 开始执行该函数。每当遇到一个 Hook（如 useState），React 会：
      - 在 Fiber 节点的 memoizedState 属性上创建一个 Hook 链表节点。
      - 将该 Hook 的初始状态存储在这个节点中。
      - 将这个 Hook 节点链接到 Fiber 的 Hook 链表上。
2. 更新： 当组件重新渲染时，React 再次执行该函数。
      - React 会严格按照 Hook 被调用的顺序，遍历 Fiber 节点上的 Hook 链表，找到对应位置的 Hook 节点，
      - 从中读取之前的状态（memoizedState），并根据新的逻辑更新状态。
## 总结
- 是的，Hook 的状态并不是存储在函数组件的闭包中（虽然闭包也起作用），而是由 React 内部管理，并直接挂载到该函数组件对应的 Fiber 节点的 memoizedState 属性上，以链表的形式组织。
- 这种设计使得 React 能够在函数组件的多次渲染之间持久化状态，并正确地追踪和更新它们。
- 理解这一点有助于深入理解 React 的工作原理和 Hook 的设计哲学。

# 为什么要用链表把hook链接起来
1. 核心原因：避免依赖索引，保证顺序一致性
    - `Hook 的调用顺序就是它的“ID”`：React 没有给每个 Hook 起名字（比如 useState('count') 中的 'count' 只是初始值，不是唯一标识符）。React 完全依赖 Hook 在函数组件中被调用的顺序 来确定哪个状态属于哪个 Hook。
    - `链表天然按顺序存储`：当你在组件中依次调用 useState、useEffect、useRef 时，React 就在 Fiber 节点上创建一个 Hook 链表，每个新 Hook 都作为 next 指针链接到上一个 Hook 之后。这个链表的遍历顺序与调用顺序严格一致。
    - `对比数组的缺陷`：如果用数组，React 也需要依赖索引（hooks[0], hooks[1]）。但数组的索引是固定的。如果某个 Hook 因为条件判断被跳过（违反规则），后续 Hook 的索引就会全部错位，导致状态错乱。链表虽然也依赖顺序，但它的结构更清晰地体现了“顺序即标识”的设计思想，并且在实现上更易于动态追加。
2. 内存效率和性能优化
    - `按需分配`: 链表是惰性创建的。只有当组件实际调用了某个 Hook 时，React 才会为它创建一个节点并链接到链表上。如果组件只用了 2 个 Hook，链表就只有 2 个节点；用了 10 个，就有 10 个节点。这比预先分配一个大数组（可能大部分位置为空）更节省内存。
    - `减少内存拷贝`: 在更新过程中，Fiber 节点可能会被复用或克隆。链表结构使得 React 可以更高效地复用已有的 Hook 节点，而不需要像数组那样进行潜在的内存拷贝或重新索引。
3. 与 Fiber 架构完美契合
    - `Fiber 本身就是树状链表结构`: React 的 Fiber 树本身就是由 child、sibling、return 等指针构成的复杂链表结构。使用链表来管理 Hook 的状态，与整个 Fiber 架构在数据结构上保持了一致性，使得协调（reconciliation）算法可以更自然地遍历和处理组件及其状态。
    - `便于副作用管理`: useEffect 等 Hook 会产生副作用（side effects）。这些副作用信息也存储在 Hook 节点中。在提交阶段（commit phase），React 需要遍历 Fiber 树来执行这些副作用。将副作用信息直接挂在 Fiber 节点的 Hook 链表上，使得查找和执行变得非常直接。
4. 简化实现逻辑
   - `单向遍历即可`：React 在每次渲染组件时，只需要从链表头开始，顺序遍历一次，就能为每个 Hook 提供正确的状态。逻辑非常简单直接。
   - `易于扩展`：添加新的 Hook 类型（如未来的 useSomethingNew）只需要定义新的 Hook 节点结构，并在链表中正确链接即可，不需要修改底层的存储机制。
