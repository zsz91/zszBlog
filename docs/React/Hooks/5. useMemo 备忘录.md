# useMemo
- useMemo : 在DOM更新前触发的，就像官方所说的，类比生命周期就是==shouldComponentUpdate==

## 实战
- useMemo 是浅比较! 如果不写g[column.dataIndex] 则监听不到值的变化
```javascript
	const CountComponent = useMemo(() => {
		if(!g.isCount){
			return null;
		}
		return <span>{g[column.dataIndex]}</span>;
	}, [column,g,g[column.dataIndex]]);
```
## React.memo

1.  要理解 React.useMemo 需要先讲 React.memo [参考React顶层Api.md](http://note.youdao.com/noteshare?id=2d315e3f09963a025078097806cc07cf\&sub=2C95CF171B3046D69434C7F2A20574BC)
2.  开销比较大的组件都要用 memo
3.  memo函数的第二个参数 也是一个函数 相当于 shouldComponentUpdate 返回 true 或 false 判断是否更新.

##### React.memo 实战 将memo函数放在函数组件外部

```javascript
import React, {useState, memo} from 'react';
import { Slider, InputNumber, Row, Col } from 'zy-web-comps';
import PrintRouterSimple from '../PrintRouterSimple';


const Child = memo(props => {
  console.log("child 执行了");
  console.log('假设这里有大量代码')
  return <PrintRouterSimple design={true}/>
});

export default function DesignFormStyle(props) {
  const [designStyle, setDesignStyle] = useState({
    scale: 1, // 缩放比例
  });

  const changeValue = (value, key='scale',) =>{
    setDesignStyle({
      ...designStyle,
      [key]: value,
    })
  }

  return (
    <main>
      <div>
        <Row>
          <Col span={1}>
            缩放比例
          </Col>
          <Col span={4}>
            <Slider
              min={0.5}
              max={3}
              step={0.05}
              dataSetKey={'scale'}
              onChange={changeValue}
              value={designStyle.scale}
            />
          </Col>
          <Col span={1}>
            <InputNumber
              min={1}
              max={20}
              dataSetKey={'scale'}
              style={{ margin: '0 16px' }}
              value={designStyle.scale}
              onChange={changeValue}
            />
          </Col>
        </Row>
      </div>
      <div>

        <Child/>
      </div>
    </main>
  )
}

```

#### 实战 主题色 模板组建闪烁bug
```javascript
   const TemplateMemo = useMemo(() => {
      return Template; // 闪烁的组件
  }, [templates, templateState]); // 组件的依赖
  
  return (
     <div>
        {TemplateMemo()}
     </div>
  );
```

#### React.useMemo 用法


- 能在useMemo中操作DOM之类的副作用操作，不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo，
- 你可以试一下，在useMemo中使用setState你会发现会产生死循环，并且会有警告，因为useMemo是在渲染中进行的，你在其中操作DOM后，又会导致memo触发

- 第一个参数是 () => value

- 第二个参数是依赖 数组,可以填空数组,可以不填 类比useEffect

- 只有当依赖变化时，才会计算出新的 value

- 如果依赖不变，那么就重用之前的 value

注意

如果你的 value 是一个函数，那么你就要写成useMemo(() => x => console.log(x))

这是一个返回函数的函数

是不是很难用？于是就有了useCallback

useCallback(x => console.log(x), \[m]) 等价于

useMemo( () => x => console.log(x), \[m])

#### React.useMemo 用途

- 性能优化的手段

- 解决React默认有多余的render
- 比如说: 改变了父组件的某一个state, 某子组件的props并未改变.但该子组件还是重新渲染了
. 使用React.useMemo 即可解决

```javascript
function App() {
    const [n, setN] = React.useState(0);
    const [m, setM] = React.useState(0);
    const onClick = () => {
        setN(n + 1);
    };

    return (
        <div className="App">
            <div>
                {/*点击button会重新执行Child组件*/}
                <button onClick={onClick}>update n {n}</button>
            </div>
            <Child data={m}/>
        </div>
    );
}

function Child(props) {
    console.log("child 执行了");
    console.log('假设这里有大量代码')
    return <div>child: {props.data}</div>;
}

```

- 将代码中的 Child 用React.memo(Child) 代替

- 如果 props 不变，就不会再次执行这个函数组件

- 最终代码：

```javascript
const Child = React.memo(props => {
        console.log("child 执行了");
        console.log('假设这里有大量代码')
        return <div>child: {props.data}</div>;
});
 function App() {
    const [n, setN] = React.useState(0);
    const [m, setM] = React.useState(0);
    const onClick = () => {
        setN(n + 1);
    };

    return (
        <div className="App">
            <div>
                {/*点击button会重新执行Child组件*/}
                <button onClick={onClick}>update n {n}</button>
            </div>
            <Child data={m}/>
        </div>
    );
}

```

这玩意有一个bug

添加了监听函数之后，一秒破功因为 App 运行时，会再次执行 onClickChild，生成新的函数

新旧函数虽然功能一样，但是地址引用不一样！
```javascript

    function App() {
        const [n, setN] = React.useState(0);
        const [m, setM] = React.useState(0);
        const onClick = () => {
            setN(n + 1);
        };
        const onClickChild = () => {}
        return (
            <div className="App">
                <div>
                    {/*点击button会重新执行Child组件*/}
                    <button onClick={onClick}>update n {n}</button>
                </div>
                {/*但是如果传了一个引用，则React.memo无效。因为引用是不相等的*/}
                <Child data={m} onClick={onClickChild}/>
            </div>
        );
    }

    //使用React.memo可以解决重新执行Child组件的问题
    const Child = React.memo(props => {
            console.log("child 执行了");
            console.log('假设这里有大量代码')
            return <div onClick={props.onClick}>child: {props.data}</div>;
    });
```

- 怎么办？ 用useMemo：
```javascript

    function App() {
        const [n, setN] = React.useState(0);
        const [m, setM] = React.useState(0);
        const onClick = () => {
            setN(n + 1);
        };
        const onClick1 = () => {
            setM(m + 1);
        };
        const onClickChild = () => {}
        const onClickChild1 = useMemo(() => {
            return () => {
                console.log(`on click child m: ${m}`)
            }
        }, [m])
        return (
            <div className="App">
                <div>
                    {/*点击button会重新执行Child组件*/}
                    <button onClick={onClick}>update n {n}</button>
                    <button onClick={onClick1}>update m {m}</button>
                </div>
                {/*但是如果传了一个引用，则React.memo无效。因为引用是不相等的*/}
                {/*<Child data={m} onClick={onClickChild}/>*/}
                {/*onClickChild1使用useMemo可以消除此bug*/}
                <Child data={m} onClick={onClickChild1}/>
            </div>
        );
    }

    //使用React.memo可以解决重新执行Child组件的问题
    const Child = React.memo(props => {
            console.log("child 执行了");
            console.log('假设这里有大量代码')
            return <div onClick={props.onClick}>child: {props.data}</div>;
    });
```

- 拓展阅读 <https://www.yuque.com/lxylona/yoyoqiekenao/tlc8hz>
