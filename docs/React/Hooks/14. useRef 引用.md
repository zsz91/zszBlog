# useRef
1. useRef: 它对标的是ref，也就是用来在render中收集dom元素,它的使用方法与useState没太大的差别，唯一要注意的是它不会直接把值return给你，而是以{current\:value}这样的形式

### 使用useRef 替换id
#### 基础使用
1.  获取dom对象
```javascript

    import React, { useState, useEffect, useMemo, useRef } from 'react';

    const couterRef = useRef();
    <button ref={couterRef} />
```
2. dom 对象: couterRef.current

#### 高阶使用

1.  在一个组件中有什么东西可以跨渲染周期，也就是在组件被多次渲染之后依旧不变的属性？第一个想到的应该是state。没错，一个组件的state可以在多次渲染之后依旧不变。但是，state的问题在于一旦修改了它就会造成组件的重新渲染。
    那么这个时候就可以使用useRef来跨越渲染周期存储数据，而且对它修改也不会引起组件渲染。
    <https://blog.csdn.net/hjc256/article/details/102587037>

```javascript
import React, { useState, useEffect, useMemo, useRef } from 'react';

export default function App(props){
  const [count, setCount] = useState(0);

  const doubleCount = useMemo(() => {
    return 2 * count;
  }, [count]);

  const timerID = useRef(0);
  
  useEffect(() => {
    timerID.current = setInterval(()=>{
        setCount(count => count + 1);
    }, 1000); 
  }, []);
  
  useEffect(()=>{
      if(count > 10){
          clearInterval(timerID.current);
          timerID.current = 0; 
          // 还原timeID 解决禅道33246
          // 如果不还原 下次还是一个大于0的数字
      }
  });
  
  return (
    <>
      <button ref={couterRef} onClick={() => {setCount(count + 1)}}>Count: {count}, double: {doubleCount}</button>
    </>
  );
}

```

- 在上面的例子中，我用ref对象的current属性来存储定时器的ID，这样便可以在多次渲染之后依旧保存定时器ID，从而能正常清除定时器。

#### 实战 验证码发送倒计时

```
import React, { useEffect, useRef, useState } from 'react';

export default function TestInterVal(props) {
	const inter = useRef(0);
	const [loadingTime, setLoadingTime] = useState(0);

	const countTime = () => {
	  setLoadingTime((c) => c -1);
  }

	useEffect(() => {
		if (loadingTime && !inter.current) {
			inter.current = window.setInterval(countTime, 1000);
		}
		if(loadingTime <= 0){
		  clearInterval(inter.current);
		  inter.current = 0;
    }
	}, [loadingTime]);


	const initTime = () => {
		setLoadingTime(5);
	};
	return <a onClick={initTime}>开始 {loadingTime}</a>;
}

```

#### 实战  InputNumber 监听失去焦点并获取最新的值
```javascript
// 5289 【正式】我的评教任务中-输入评分时鼠标选中问题优化
import React, { useRef, useEffect, useState } from 'react';
import { InputNumber, message } from 'antd';

export default function InputNumberRef(props) {
	const { onChange, min = 0, max = 99 } = props;
	const [value, setValue] = useState(props.defaultValue);
	const ref = useRef();
	function handleChange(v) {
		// if(props.min > v || props.max < v) {
		// 	message.warning('')
		// }
		setValue(v);
	}
	const handleBlur = ()=> {
		let trueValue = Number(ref.current.value || 0);
		if(trueValue < min) {
			trueValue = min;
		}else if (trueValue > max) {
			trueValue = max;
		}
		// console.log('失去焦点时获得的值',trueValue);
		onChange(trueValue);
	}
	// console.log('真正的值 = ',value, '父组件传入的值=', props.defaultValue,);
	return <InputNumber {...props}
											value={value}
											onChange={handleChange}
											onBlur={handleBlur}
											ref={ref}
	/>;
}

```
