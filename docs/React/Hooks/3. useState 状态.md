# useState
1.  如果state是一个对象,不可局部更新
2.  useState无论调用多少次，``相互之间是独立的``。这一点至关重要
3.  看下面的代码 如果快速的调用多次且每次的key 不同 会导致赋值错误 原因 React 会``合并多次的setState 到一次执行``

#### 知识大纲
1.  useState 是简化了的 useReducer
2.  所有的hooks 均是同一核心原理.
3.  在最下方有一个 useState 的基本实现. 核心就是 链表 与 环形链表
    ![image](https://note.youdao.com/yws/public/resource/87480655210f03f98e1d7f9075a60801/xmlnote/42D1F947E35F4121A5802B9E6138EE99/7EA217F81AF04E41B849C316B813A6D6/27764)

#### state改变让Input 失去焦点
```javascript
// 使用函数设置变量
    setBoxes((oldBox)=>{
             return [...oldBox, item];
    });
```

#### 实战-闭包导致无法更新state  使用函数式更新解决
```javascript
      const [boxes, setBoxes] = useState([]);
      const [, drop] = useDrop(() => {
        return {
          accept: 'box',
          drop(item) {
            item.id = randomKey();
            const oldBox = [...boxes]; // 由于闭包导致boxes始终是初始值[]
            oldBox.push(item);
            setBoxes(oldBox); 
            console.log(item);
          },
        };
      });

     setBoxes((oldBox)=>{
         return [...oldBox, item];
     });
```

#### 注意事项
-  react规定我们必须把hooks写在函数的最外层，不能写在if else for等语句当中，来确保hooks的执行顺序一致。

```javascript
 setCascadeSearchValue({
      ...CascadeSearchValue,
      [key]: value,
    }); // 这样写存在异步问题.如果快速的调用多次且每次的key 不同 会导致赋值错误 原因 React 会合并多次的setState 到一次执行

 // 以下代码则没有这个问题- 函数式更新
 setCascadeSearchValue((oldValue) => {
   console.log(oldValue);
   return {
     ...oldValue,
     [key]: value,
   }
 });

```

1.  setState(obj) 如果obj``地址``不变，那么React就认为数据没有变化，不会更新视图.
2.  反之 如果obj的内存地址改变了 就会触发更新视图.

#### 特别的
1. useState 可以接受一个函数 该函数返回初始state，且只执行一次
    .该函数仅在初始渲染时执行
```javascript
 const [state, setState] = useState(() => {
    return initialState
 })
```

2. setState 可以接受一个函数 函数的参数是之前的state 返回值是新的state

```javascript
  setState((oldState)=>{
      return oldState + 1;
  })
  
  const [age, setAge] = useState(29);
  setAge((oldAge)=>{
      let newAge += oldAge
      return newAge; 
  })
  
```

#### 如何实现类组件中的 setState 的同步功能

1.  使用useEffect 监听 需要同步的state 即可

#### setState传入函数与传入值之间的区别
- 一个能拿到最新值.
- 一个不能拿到最新值. 闭包 事件合成机制导致的

#### 手写一个useState hooks 卡颂的代码
- [B站](https://www.bilibili.com/video/BV1iV411b7L1)

```javascript
/**
 * 实现一个 react hooks的 useState
 */
let isMount = true;
let workInProgressHook = null; // 全局的链表 当前执行的 state 

function App(){
    const [num, updateNum] = useState(0);
    const [num1, updateNum1] = useState(22);
    const [num2, updateNum2] = useState(33);
    console.log('isMount?', isMount);
    console.log(`num: `, num);

    return {
        onClick: () => {
            updateNum(x  => x + 1);
            updateNum1(y => y + 10);
        }
    }
}


const fiber = {
   stateNode: App,
   memoizedStates: null, // 链表 函数组件每一个hook;

};

function schedule(){
    workInProgressHook = fiber.memoizedStates;
    const app = fiber.stateNode();
    isMount = false;
    return app;
}




function useState(initialState){
   let hook;
   if(isMount){ // 首次渲染
    hook = {
        memoizedStates: initialState,
        next: null,
        queue: { // 环状链表队列
            pending: null, // 下一个要执行的东西
        }, 
    }
    if(!fiber.memoizedStates){
        fiber.memoizedStates = hook; //第一个useState 
    } else {
        workInProgressHook.next = hook; // 其余useState 将hook 赋值给 fibel.memoizedStates.next
    }
    workInProgressHook = hook; // 当前的hook
   }
   
   else { // 组件更新时 一样调用这里的方法 更新数据
    hook = workInProgressHook;
    workInProgressHook = workInProgressHook.next; // 获得下一个hook
   }

   let baseState = hook.memoizedStates;
   if(hook.queue.pending){
       let firstUpdate = hook.queue.pending.next;
       do{
           const action = firstUpdate.action;
           baseState = action(baseState);
           firstUpdate = firstUpdate.next;
       } while( firstUpdate !== hook.queue.pending.next) // 遍历环状链表
       hook.queue.pending = null;
   }

   hook.memoizedStates = baseState; // 新的state值
   console.log(hook.queue);
   return [baseState, dispathAction.bind(null, hook.queue)];

}


function dispathAction(queue, action){
    const update = {
        action,
        next: null,
    };
    if (queue.pending === null) {  // 环状链表
        update.next = update;
    } else {  
         update.next = queue.pending.next;
         queue.pending.next = update;
    }
    queue.pending = update;
    schedule(); // 重新render 组件
}

window.app = schedule();

```

