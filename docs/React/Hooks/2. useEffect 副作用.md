# useEffect
- 规则限制: useEffect 要么不返回任何东西, 要么返回清理函数.
## 概念

1.  对环境的改变即为副作用，如修改 document.title
2.  但我们不一定非要把副作用放在 useEffect 里面
3.  实际上叫做 afterRender 更好，每次render后执行
4.  如果同时存在多个 useEffect， 会按照出现次序执行 (链表存储)

## 用途

#### 任何一个state改变时触发(不传第二个参数)
```javascript
     useEffect(() => {
        console.log('任何一个state改变时触发');
     });
```

##### 作为 componentDidMount 使用，空数组 作第二个参数
```javascript
    useEffect(() => {
    		console.log('我相当于componentDidMount');
    	}, []);
```

##### 作为 componentDidUpdate 使用，可指定依赖.

如果依赖中有1个或多个state,在组件挂载时会执行1次这个effect. 因为初始化state时也会调用这个effect

```javascript
  useEffect(() => {
		console.log('作为 componentDidUpdate 使用，可指定依赖');
	}, [stateN, stateB]); //挂载时将执行此effect

```

#### 作为 componentWillUnmount 使用，通过 return
```javascript

    useEffect(()=>{
            console.log('Index页面--来了---'); // componentDidMount  
            return ()=>{
                console.log('Index页面--走了---'); // componentWillUnmount 
            }
        },[])
```
#### 作为 componentDidUpdate 使用，有依赖

```javascript
useEffect(
    ()=>{
        return () => {
            // 每次state 更新前都会执行
            // 比如 从1 变为 2 则执行1次. 初始化不执行.
        }
}, [state])
```

#### 在addEventListener 中无法获取最新的state

<https://blog.csdn.net/weixin_46554760/article/details/109177309>

```javascript
// 实战 解决获取不到最新的state
useEffect(() => {
    if(lowCodeEdit?.beforeShow){
      window.addEventListener('storage', handleLocalStorageSave);
    }
    return () => {
      window.removeEventListener('storage', handleLocalStorageSave);
    };
}, [lowCodeEdit.beforeShow]);

```
